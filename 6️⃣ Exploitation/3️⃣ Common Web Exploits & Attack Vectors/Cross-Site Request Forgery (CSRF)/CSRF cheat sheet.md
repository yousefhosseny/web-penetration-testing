لاختبار ثغرة **Cross-Site Request Forgery (CSRF)** انت بتخش علي الموقع وبتشوف اي الاماكن اللي في الموقع  اللي ممكن تغير بيانات زي (تغيير اسم المستخدم أو تحديث صلاحيات او الايميل او ال address او رقم التليفون  ) واستخدم فيها ال CSRF

### فكره عامه عن الثغره

![[Recording 20250630170751.m4a]]


---


## هام جدا :

![[Pasted image 20250423222716.png|1426]]
# CSRF Cheat Sheet

ورقة مرجعية لاختبار ثغرات **CSRF** (Cross-Site Request Forgery) بشكل منهجي. الورقة مقسمة إلى مراحل لتسهيل فحص التطبيقات المستهدفة واكتشاف الثغرات بفعالية.

## المرحلة 1: فهم التطبيق المستهدف

- **الهدف**: تحليل التطبيق لتحديد النقاط الحساسة التي يمكن استهدافها.
- **الخطوات**:
    - حدد نوع التطبيق (Web, Mobile-only, SPA, API-based).
    - افحص نقاط الـ endpoints الحساسة (مثل تغيير كلمة المرور، تحويل الأموال، إلخ).
    - تحقق من آليات المصادقة (Cookies, Tokens, Headers).
    - لاحظ إعدادات CORS وSameSite Cookies إن وجدت.

## المرحلة 2: اختبار طلبات HTML

اختبارات للطلبات التي تستخدم نماذج HTML (GET وPOST) مع أو بدون تفاعل المستخدم.

### 2.1 اختبار HTML GET

#### - **يتطلب تفاعل المستخدم**:
- أنشئ رابطًا يحتوي على طلب GET (مثل `<a href="https://target.com/action?param=value">Click</a>`).
- تحقق إذا كان التطبيق ينفذ الطلب بدون التحقق من CSRF Token.
#### - **بدون تفاعل المستخدم**:
- استخدم عناصر تلقائية مثل `<img src="https://target.com/action?param=value">` أو `<iframe>`.
- تحقق إذا كان الطلب يُنفذ تلقائيًا عند تحميل الصفحة.
##### الشرح العملي :

![[2025-07-01 07-53-18.mkv]]
### 2.2 اختبار HTML POST

#### - **يتطلب تفاعل المستخدم**:
- أنشئ نموذج HTML يحتوي على طلب POST (مثل `<form action="https://target.com/action" method="POST">`).
- أضف حقول النموذج المطلوبة وزر إرسال.
- تحقق إذا كان التطبيق يقبل الطلب بدون CSRF Token.
#### - **إرسال تلقائي (بدون تفاعل)**:
- استخدم JavaScript لإرسال النموذج تلقائيًا (مثل `document.forms[0].submit()`).
 - تحقق إذا كان التطبيق ينفذ الطلب بدون التحقق من الـ Token.

![[Pasted image 20250423233227.png]]
##### الشرح العملي :

![[2025-07-01 06-18-24.mkv]]


### - 2.3 **multipart/form-data مع رفع ملف**:
- أنشئ نموذج POST باستخدام `enctype="multipart/form-data"` لمحاكاة رفع ملف.
- تحقق إذا كان التطبيق يسمح بتنفيذ الطلب بدون التحقق من الـ Token أو قيود على نوع الملف.

## المرحلة 3: اختبار طلبات JSON

اختبارات لطلبات JSON (GET وPOST) التي تُستخدم غالبًا في الـ APIs أو التطبيقات الحديثة.

### 3.1 اختبار JSON GET

- أنشئ طلب GET باستخدام `<img>` أو `<script>` (مثل `<script src="https://target.com/api/action?param=value"></script>`).
- تحقق إذا كان التطبيق ينفذ الطلب بدون التحقق من الـ Origin أو CSRF Token.

### 3.2 اختبار JSON POST

- **طلبات بسيطة**:
    - أنشئ طلب POST باستخدام `XMLHttpRequest` أو `fetch` مع Content-Type: `application/json`.
    - أرسل payload بسيط (مثل `{"param": "value"}`).
    - تحقق إذا كان التطبيق يقبل الطلب بدون CSRF Token.
- **طلبات معقدة**:
    - أضف headers مخصصة أو payload معقد (مثل nested JSON objects).
    - استخدم أدوات مثل Postman أو Burp Suite لتحليل استجابة التطبيق.
    - تحقق إذا كان التطبيق يفرض التحقق من Content-Type أو CSRF Token.

## المرحلة 4: فحص آليات الحماية

اختبار آليات الحماية ضد CSRF والتحقق من إمكانية تجاوزها.

### 4.1 التحقق من وجود CSRF Tokens

- ابحث عن CSRF Tokens في المعلمات (parameters)، الـ headers، أو النماذج المخفية.
- تحقق إذا كان التطبيق يتحقق من الـ Token بشكل صحيح.
- حاول إرسال طلب بدون Token أو بـ Token غير صحيح.

### 4.2 اختبار SameSite Cookies

- تحقق من إعدادات SameSite للـ Cookies (Strict، Lax، أو None).
- إذا كان SameSite=Strict، التطبيق غالبًا محمي من CSRF.
- إذا كان SameSite=None، حاول استغلال الطلبات عبر مواقع خارجية.

### 4.3 اختبار Double Submit Cookie

- تحقق إذا كان التطبيق يستخدم آلية Double Submit Cookie (إرسال Token في Cookie وفي المعلمات/headers).
- حاول إرسال طلب بدون مطابقة بين الـ Cookie والـ Token.

### 4.4 التحقق من Referer/Origin Headers

- أرسل طلبات مع تعديل Referer أو Origin headers.
- تحقق إذا كان التطبيق يعتمد على هذه الـ headers كآلية حماية.
- حاول تجاوز التحقق باستخدام قيم مزيفة أو إزالة الـ headers.

## المرحلة 5: اختبار CSRF في سياقات خاصة

اختبارات لسيناريوهات محددة مثل التطبيقات أحادية الصفحة (SPA) أو الـ APIs.

### 5.1 اختبار التطبيقات أحادية الصفحة (SPA)

- تحقق من استخدام الـ AJAX requests في التطبيقات مثل React أو Angular.
- حاول إرسال طلبات JSON عبر `XMLHttpRequest` أو `fetch` من موقع خارجي.
- تحقق من وجود CSRF Tokens أو آليات حماية أخرى.

### 5.2 اختبار CSRF في APIs

- ركز على الـ endpoints التي تستخدم JSON أو Content-Types أخرى.
- تحقق إذا كان الـ API يطلب CSRF Token أو يعتمد على الـ Authentication headers.
- حاول إرسال طلبات من مصادر غير مصرح بها (Unauthorized Origins).

### 5.3 التحقق من التطبيقات المستخدمة فقط عبر الموبايل

- إذا كان التطبيق موجه للموبايل فقط، تحقق من استخدام API Tokens أو آليات مصادقة أخرى.
- حاول محاكاة طلبات الـ API من متصفح أو مصدر خارجي.

## المرحلة 6: استخدام أدوات تلقائية

- استخدم أدوات مثل **Burp Suite** أو **CSRF PoC Generator** لإنشاء طلبات CSRF تلقائيًا.
- استخدم **Postman** لاختبار طلبات JSON أو POST المعقدة.
- جرب أدوات مثل **OWASP ZAP** لفحص الثغرات بشكل شامل.

## المرحلة 7: اختبار CORS (اختياري)

- إذا كان التطبيق يعتمد على طلبات JSON أو APIs، تحقق من إعدادات CORS:
    - أرسل طلب OPTIONS للتحقق من Access-Control-Allow-Origin.
    - تحقق إذا كان التطبيق يسمح بطلبات من مصادر غير مصرح بها.
- ملحوظة: هذه الخطوة أقرب لاختبارات CORS، لكنها قد تكون ذات صلة إذا كانت الثغرة تعتمد على سوء إعداد CORS.

## أمثلة عملية

### مثال 1: طلب HTML POST تلقائي

```html
<form id="csrfForm" action="https://target.com/action" method="POST">
    <input type="hidden" name="param" value="malicious_value">
</form>
<script>
    document.getElementById("csrfForm").submit();
</script>
```

### مثال 2: طلب JSON POST باستخدام XMLHttpRequest

```javascript
var xhr = new XMLHttpRequest();
xhr.open("POST", "https://target.com/api/action", true);
xhr.setRequestHeader("Content-Type", "application/json");
xhr.send(JSON.stringify({"param": "malicious_value"}));
```

## ملاحظات إضافية

- ركز على الطلبات الحساسة (مثل تغيير البيانات أو إجراءات المستخدم).
- وثّق كل خطوة ونتائجها لإعداد تقرير الثغرة.
- تأكد من اختبار التطبيق في بيئة آمنة وقانونية.


